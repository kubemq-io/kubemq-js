/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.3
 * source: kubemq.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace kubemq {
    export enum StreamRequestType {
        StreamRequestTypeUnknown = 0,
        ReceiveMessage = 1,
        AckMessage = 2,
        RejectMessage = 3,
        ModifyVisibility = 4,
        ResendMessage = 5,
        SendModifiedMessage = 6
    }
    export enum QueuesDownstreamRequestType {
        PollRequestTypeUnknown = 0,
        Get = 1,
        AckAll = 2,
        AckRange = 3,
        NAckAll = 4,
        NAckRange = 5,
        ReQueueAll = 6,
        ReQueueRange = 7,
        ActiveOffsets = 8,
        TransactionStatus = 9,
        CloseByClient = 10,
        CloseByServer = 11
    }
    export class PingResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Host?: string;
            Version?: string;
            ServerStartTime?: number;
            ServerUpTimeSeconds?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Host" in data && data.Host != undefined) {
                    this.Host = data.Host;
                }
                if ("Version" in data && data.Version != undefined) {
                    this.Version = data.Version;
                }
                if ("ServerStartTime" in data && data.ServerStartTime != undefined) {
                    this.ServerStartTime = data.ServerStartTime;
                }
                if ("ServerUpTimeSeconds" in data && data.ServerUpTimeSeconds != undefined) {
                    this.ServerUpTimeSeconds = data.ServerUpTimeSeconds;
                }
            }
        }
        get Host() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set Host(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Version() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set Version(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get ServerStartTime() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set ServerStartTime(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get ServerUpTimeSeconds() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set ServerUpTimeSeconds(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            Host?: string;
            Version?: string;
            ServerStartTime?: number;
            ServerUpTimeSeconds?: number;
        }): PingResult {
            const message = new PingResult({});
            if (data.Host != null) {
                message.Host = data.Host;
            }
            if (data.Version != null) {
                message.Version = data.Version;
            }
            if (data.ServerStartTime != null) {
                message.ServerStartTime = data.ServerStartTime;
            }
            if (data.ServerUpTimeSeconds != null) {
                message.ServerUpTimeSeconds = data.ServerUpTimeSeconds;
            }
            return message;
        }
        toObject() {
            const data: {
                Host?: string;
                Version?: string;
                ServerStartTime?: number;
                ServerUpTimeSeconds?: number;
            } = {};
            if (this.Host != null) {
                data.Host = this.Host;
            }
            if (this.Version != null) {
                data.Version = this.Version;
            }
            if (this.ServerStartTime != null) {
                data.ServerStartTime = this.ServerStartTime;
            }
            if (this.ServerUpTimeSeconds != null) {
                data.ServerUpTimeSeconds = this.ServerUpTimeSeconds;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Host.length)
                writer.writeString(1, this.Host);
            if (this.Version.length)
                writer.writeString(2, this.Version);
            if (this.ServerStartTime != 0)
                writer.writeInt64(3, this.ServerStartTime);
            if (this.ServerUpTimeSeconds != 0)
                writer.writeInt64(4, this.ServerUpTimeSeconds);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PingResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PingResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Host = reader.readString();
                        break;
                    case 2:
                        message.Version = reader.readString();
                        break;
                    case 3:
                        message.ServerStartTime = reader.readInt64();
                        break;
                    case 4:
                        message.ServerUpTimeSeconds = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PingResult {
            return PingResult.deserialize(bytes);
        }
    }
    export class Empty extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): Empty {
            const message = new Empty({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Empty();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Empty {
            return Empty.deserialize(bytes);
        }
    }
    export class Result extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            EventID?: string;
            Sent?: boolean;
            Error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("EventID" in data && data.EventID != undefined) {
                    this.EventID = data.EventID;
                }
                if ("Sent" in data && data.Sent != undefined) {
                    this.Sent = data.Sent;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
            }
        }
        get EventID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set EventID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Sent() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set Sent(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            EventID?: string;
            Sent?: boolean;
            Error?: string;
        }): Result {
            const message = new Result({});
            if (data.EventID != null) {
                message.EventID = data.EventID;
            }
            if (data.Sent != null) {
                message.Sent = data.Sent;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            return message;
        }
        toObject() {
            const data: {
                EventID?: string;
                Sent?: boolean;
                Error?: string;
            } = {};
            if (this.EventID != null) {
                data.EventID = this.EventID;
            }
            if (this.Sent != null) {
                data.Sent = this.Sent;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.EventID.length)
                writer.writeString(1, this.EventID);
            if (this.Sent != false)
                writer.writeBool(2, this.Sent);
            if (this.Error.length)
                writer.writeString(3, this.Error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Result {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Result();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.EventID = reader.readString();
                        break;
                    case 2:
                        message.Sent = reader.readBool();
                        break;
                    case 3:
                        message.Error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Result {
            return Result.deserialize(bytes);
        }
    }
    export class Event extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            EventID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Store?: boolean;
            Tags?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("EventID" in data && data.EventID != undefined) {
                    this.EventID = data.EventID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
                if ("Body" in data && data.Body != undefined) {
                    this.Body = data.Body;
                }
                if ("Store" in data && data.Store != undefined) {
                    this.Store = data.Store;
                }
                if ("Tags" in data && data.Tags != undefined) {
                    this.Tags = data.Tags;
                }
            }
            if (!this.Tags)
                this.Tags = new Map();
        }
        get EventID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set EventID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Metadata() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Metadata(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Body() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set Body(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get Store() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set Store(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get Tags() {
            return pb_1.Message.getField(this, 7) as any as Map<string, string>;
        }
        set Tags(value: Map<string, string>) {
            pb_1.Message.setField(this, 7, value as any);
        }
        static fromObject(data: {
            EventID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Store?: boolean;
            Tags?: {
                [key: string]: string;
            };
        }): Event {
            const message = new Event({});
            if (data.EventID != null) {
                message.EventID = data.EventID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.Metadata != null) {
                message.Metadata = data.Metadata;
            }
            if (data.Body != null) {
                message.Body = data.Body;
            }
            if (data.Store != null) {
                message.Store = data.Store;
            }
            if (typeof data.Tags == "object") {
                message.Tags = new Map(Object.entries(data.Tags));
            }
            return message;
        }
        toObject() {
            const data: {
                EventID?: string;
                ClientID?: string;
                Channel?: string;
                Metadata?: string;
                Body?: Uint8Array;
                Store?: boolean;
                Tags?: {
                    [key: string]: string;
                };
            } = {};
            if (this.EventID != null) {
                data.EventID = this.EventID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.Metadata != null) {
                data.Metadata = this.Metadata;
            }
            if (this.Body != null) {
                data.Body = this.Body;
            }
            if (this.Store != null) {
                data.Store = this.Store;
            }
            if (this.Tags != null) {
                data.Tags = (Object.fromEntries)(this.Tags);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.EventID.length)
                writer.writeString(1, this.EventID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.Channel.length)
                writer.writeString(3, this.Channel);
            if (this.Metadata.length)
                writer.writeString(4, this.Metadata);
            if (this.Body.length)
                writer.writeBytes(5, this.Body);
            if (this.Store != false)
                writer.writeBool(6, this.Store);
            for (const [key, value] of this.Tags) {
                writer.writeMessage(7, this.Tags, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.EventID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.Channel = reader.readString();
                        break;
                    case 4:
                        message.Metadata = reader.readString();
                        break;
                    case 5:
                        message.Body = reader.readBytes();
                        break;
                    case 6:
                        message.Store = reader.readBool();
                        break;
                    case 7:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Tags as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Event {
            return Event.deserialize(bytes);
        }
    }
    export class EventReceive extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            EventID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Timestamp?: number;
            Sequence?: number;
            Tags?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("EventID" in data && data.EventID != undefined) {
                    this.EventID = data.EventID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
                if ("Body" in data && data.Body != undefined) {
                    this.Body = data.Body;
                }
                if ("Timestamp" in data && data.Timestamp != undefined) {
                    this.Timestamp = data.Timestamp;
                }
                if ("Sequence" in data && data.Sequence != undefined) {
                    this.Sequence = data.Sequence;
                }
                if ("Tags" in data && data.Tags != undefined) {
                    this.Tags = data.Tags;
                }
            }
            if (!this.Tags)
                this.Tags = new Map();
        }
        get EventID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set EventID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Metadata() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Metadata(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Body() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set Body(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get Timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set Timestamp(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Sequence() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set Sequence(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Tags() {
            return pb_1.Message.getField(this, 7) as any as Map<string, string>;
        }
        set Tags(value: Map<string, string>) {
            pb_1.Message.setField(this, 7, value as any);
        }
        static fromObject(data: {
            EventID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Timestamp?: number;
            Sequence?: number;
            Tags?: {
                [key: string]: string;
            };
        }): EventReceive {
            const message = new EventReceive({});
            if (data.EventID != null) {
                message.EventID = data.EventID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.Metadata != null) {
                message.Metadata = data.Metadata;
            }
            if (data.Body != null) {
                message.Body = data.Body;
            }
            if (data.Timestamp != null) {
                message.Timestamp = data.Timestamp;
            }
            if (data.Sequence != null) {
                message.Sequence = data.Sequence;
            }
            if (typeof data.Tags == "object") {
                message.Tags = new Map(Object.entries(data.Tags));
            }
            return message;
        }
        toObject() {
            const data: {
                EventID?: string;
                Channel?: string;
                Metadata?: string;
                Body?: Uint8Array;
                Timestamp?: number;
                Sequence?: number;
                Tags?: {
                    [key: string]: string;
                };
            } = {};
            if (this.EventID != null) {
                data.EventID = this.EventID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.Metadata != null) {
                data.Metadata = this.Metadata;
            }
            if (this.Body != null) {
                data.Body = this.Body;
            }
            if (this.Timestamp != null) {
                data.Timestamp = this.Timestamp;
            }
            if (this.Sequence != null) {
                data.Sequence = this.Sequence;
            }
            if (this.Tags != null) {
                data.Tags = (Object.fromEntries)(this.Tags);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.EventID.length)
                writer.writeString(1, this.EventID);
            if (this.Channel.length)
                writer.writeString(2, this.Channel);
            if (this.Metadata.length)
                writer.writeString(3, this.Metadata);
            if (this.Body.length)
                writer.writeBytes(4, this.Body);
            if (this.Timestamp != 0)
                writer.writeInt64(5, this.Timestamp);
            if (this.Sequence != 0)
                writer.writeUint64(6, this.Sequence);
            for (const [key, value] of this.Tags) {
                writer.writeMessage(7, this.Tags, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventReceive {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventReceive();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.EventID = reader.readString();
                        break;
                    case 2:
                        message.Channel = reader.readString();
                        break;
                    case 3:
                        message.Metadata = reader.readString();
                        break;
                    case 4:
                        message.Body = reader.readBytes();
                        break;
                    case 5:
                        message.Timestamp = reader.readInt64();
                        break;
                    case 6:
                        message.Sequence = reader.readUint64();
                        break;
                    case 7:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Tags as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventReceive {
            return EventReceive.deserialize(bytes);
        }
    }
    export class Subscribe extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            SubscribeTypeData?: Subscribe.SubscribeType;
            ClientID?: string;
            Channel?: string;
            Group?: string;
            EventsStoreTypeData?: Subscribe.EventsStoreType;
            EventsStoreTypeValue?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("SubscribeTypeData" in data && data.SubscribeTypeData != undefined) {
                    this.SubscribeTypeData = data.SubscribeTypeData;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("Group" in data && data.Group != undefined) {
                    this.Group = data.Group;
                }
                if ("EventsStoreTypeData" in data && data.EventsStoreTypeData != undefined) {
                    this.EventsStoreTypeData = data.EventsStoreTypeData;
                }
                if ("EventsStoreTypeValue" in data && data.EventsStoreTypeValue != undefined) {
                    this.EventsStoreTypeValue = data.EventsStoreTypeValue;
                }
            }
        }
        get SubscribeTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 1, Subscribe.SubscribeType.SubscribeTypeUndefined) as Subscribe.SubscribeType;
        }
        set SubscribeTypeData(value: Subscribe.SubscribeType) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Group() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Group(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get EventsStoreTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 5, Subscribe.EventsStoreType.EventsStoreTypeUndefined) as Subscribe.EventsStoreType;
        }
        set EventsStoreTypeData(value: Subscribe.EventsStoreType) {
            pb_1.Message.setField(this, 5, value);
        }
        get EventsStoreTypeValue() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set EventsStoreTypeValue(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            SubscribeTypeData?: Subscribe.SubscribeType;
            ClientID?: string;
            Channel?: string;
            Group?: string;
            EventsStoreTypeData?: Subscribe.EventsStoreType;
            EventsStoreTypeValue?: number;
        }): Subscribe {
            const message = new Subscribe({});
            if (data.SubscribeTypeData != null) {
                message.SubscribeTypeData = data.SubscribeTypeData;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.Group != null) {
                message.Group = data.Group;
            }
            if (data.EventsStoreTypeData != null) {
                message.EventsStoreTypeData = data.EventsStoreTypeData;
            }
            if (data.EventsStoreTypeValue != null) {
                message.EventsStoreTypeValue = data.EventsStoreTypeValue;
            }
            return message;
        }
        toObject() {
            const data: {
                SubscribeTypeData?: Subscribe.SubscribeType;
                ClientID?: string;
                Channel?: string;
                Group?: string;
                EventsStoreTypeData?: Subscribe.EventsStoreType;
                EventsStoreTypeValue?: number;
            } = {};
            if (this.SubscribeTypeData != null) {
                data.SubscribeTypeData = this.SubscribeTypeData;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.Group != null) {
                data.Group = this.Group;
            }
            if (this.EventsStoreTypeData != null) {
                data.EventsStoreTypeData = this.EventsStoreTypeData;
            }
            if (this.EventsStoreTypeValue != null) {
                data.EventsStoreTypeValue = this.EventsStoreTypeValue;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.SubscribeTypeData != Subscribe.SubscribeType.SubscribeTypeUndefined)
                writer.writeEnum(1, this.SubscribeTypeData);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.Channel.length)
                writer.writeString(3, this.Channel);
            if (this.Group.length)
                writer.writeString(4, this.Group);
            if (this.EventsStoreTypeData != Subscribe.EventsStoreType.EventsStoreTypeUndefined)
                writer.writeEnum(5, this.EventsStoreTypeData);
            if (this.EventsStoreTypeValue != 0)
                writer.writeInt64(6, this.EventsStoreTypeValue);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Subscribe {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Subscribe();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.SubscribeTypeData = reader.readEnum();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.Channel = reader.readString();
                        break;
                    case 4:
                        message.Group = reader.readString();
                        break;
                    case 5:
                        message.EventsStoreTypeData = reader.readEnum();
                        break;
                    case 6:
                        message.EventsStoreTypeValue = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Subscribe {
            return Subscribe.deserialize(bytes);
        }
    }
    export namespace Subscribe {
        export enum SubscribeType {
            SubscribeTypeUndefined = 0,
            Events = 1,
            EventsStore = 2,
            Commands = 3,
            Queries = 4
        }
        export enum EventsStoreType {
            EventsStoreTypeUndefined = 0,
            StartNewOnly = 1,
            StartFromFirst = 2,
            StartFromLast = 3,
            StartAtSequence = 4,
            StartAtTime = 5,
            StartAtTimeDelta = 6
        }
    }
    export class Request extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            RequestTypeData?: Request.RequestType;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            ReplyChannel?: string;
            Timeout?: number;
            CacheKey?: string;
            CacheTTL?: number;
            Span?: Uint8Array;
            Tags?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("RequestTypeData" in data && data.RequestTypeData != undefined) {
                    this.RequestTypeData = data.RequestTypeData;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
                if ("Body" in data && data.Body != undefined) {
                    this.Body = data.Body;
                }
                if ("ReplyChannel" in data && data.ReplyChannel != undefined) {
                    this.ReplyChannel = data.ReplyChannel;
                }
                if ("Timeout" in data && data.Timeout != undefined) {
                    this.Timeout = data.Timeout;
                }
                if ("CacheKey" in data && data.CacheKey != undefined) {
                    this.CacheKey = data.CacheKey;
                }
                if ("CacheTTL" in data && data.CacheTTL != undefined) {
                    this.CacheTTL = data.CacheTTL;
                }
                if ("Span" in data && data.Span != undefined) {
                    this.Span = data.Span;
                }
                if ("Tags" in data && data.Tags != undefined) {
                    this.Tags = data.Tags;
                }
            }
            if (!this.Tags)
                this.Tags = new Map();
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get RequestTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 2, Request.RequestType.RequestTypeUnknown) as Request.RequestType;
        }
        set RequestTypeData(value: Request.RequestType) {
            pb_1.Message.setField(this, 2, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Metadata() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set Metadata(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get Body() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set Body(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get ReplyChannel() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set ReplyChannel(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get Timeout() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set Timeout(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get CacheKey() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set CacheKey(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get CacheTTL() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set CacheTTL(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get Span() {
            return pb_1.Message.getFieldWithDefault(this, 11, new Uint8Array(0)) as Uint8Array;
        }
        set Span(value: Uint8Array) {
            pb_1.Message.setField(this, 11, value);
        }
        get Tags() {
            return pb_1.Message.getField(this, 12) as any as Map<string, string>;
        }
        set Tags(value: Map<string, string>) {
            pb_1.Message.setField(this, 12, value as any);
        }
        static fromObject(data: {
            RequestID?: string;
            RequestTypeData?: Request.RequestType;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            ReplyChannel?: string;
            Timeout?: number;
            CacheKey?: string;
            CacheTTL?: number;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        }): Request {
            const message = new Request({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.RequestTypeData != null) {
                message.RequestTypeData = data.RequestTypeData;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.Metadata != null) {
                message.Metadata = data.Metadata;
            }
            if (data.Body != null) {
                message.Body = data.Body;
            }
            if (data.ReplyChannel != null) {
                message.ReplyChannel = data.ReplyChannel;
            }
            if (data.Timeout != null) {
                message.Timeout = data.Timeout;
            }
            if (data.CacheKey != null) {
                message.CacheKey = data.CacheKey;
            }
            if (data.CacheTTL != null) {
                message.CacheTTL = data.CacheTTL;
            }
            if (data.Span != null) {
                message.Span = data.Span;
            }
            if (typeof data.Tags == "object") {
                message.Tags = new Map(Object.entries(data.Tags));
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                RequestTypeData?: Request.RequestType;
                ClientID?: string;
                Channel?: string;
                Metadata?: string;
                Body?: Uint8Array;
                ReplyChannel?: string;
                Timeout?: number;
                CacheKey?: string;
                CacheTTL?: number;
                Span?: Uint8Array;
                Tags?: {
                    [key: string]: string;
                };
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.RequestTypeData != null) {
                data.RequestTypeData = this.RequestTypeData;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.Metadata != null) {
                data.Metadata = this.Metadata;
            }
            if (this.Body != null) {
                data.Body = this.Body;
            }
            if (this.ReplyChannel != null) {
                data.ReplyChannel = this.ReplyChannel;
            }
            if (this.Timeout != null) {
                data.Timeout = this.Timeout;
            }
            if (this.CacheKey != null) {
                data.CacheKey = this.CacheKey;
            }
            if (this.CacheTTL != null) {
                data.CacheTTL = this.CacheTTL;
            }
            if (this.Span != null) {
                data.Span = this.Span;
            }
            if (this.Tags != null) {
                data.Tags = (Object.fromEntries)(this.Tags);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.RequestTypeData != Request.RequestType.RequestTypeUnknown)
                writer.writeEnum(2, this.RequestTypeData);
            if (this.ClientID.length)
                writer.writeString(3, this.ClientID);
            if (this.Channel.length)
                writer.writeString(4, this.Channel);
            if (this.Metadata.length)
                writer.writeString(5, this.Metadata);
            if (this.Body.length)
                writer.writeBytes(6, this.Body);
            if (this.ReplyChannel.length)
                writer.writeString(7, this.ReplyChannel);
            if (this.Timeout != 0)
                writer.writeInt32(8, this.Timeout);
            if (this.CacheKey.length)
                writer.writeString(9, this.CacheKey);
            if (this.CacheTTL != 0)
                writer.writeInt32(10, this.CacheTTL);
            if (this.Span.length)
                writer.writeBytes(11, this.Span);
            for (const [key, value] of this.Tags) {
                writer.writeMessage(12, this.Tags, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Request {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Request();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.RequestTypeData = reader.readEnum();
                        break;
                    case 3:
                        message.ClientID = reader.readString();
                        break;
                    case 4:
                        message.Channel = reader.readString();
                        break;
                    case 5:
                        message.Metadata = reader.readString();
                        break;
                    case 6:
                        message.Body = reader.readBytes();
                        break;
                    case 7:
                        message.ReplyChannel = reader.readString();
                        break;
                    case 8:
                        message.Timeout = reader.readInt32();
                        break;
                    case 9:
                        message.CacheKey = reader.readString();
                        break;
                    case 10:
                        message.CacheTTL = reader.readInt32();
                        break;
                    case 11:
                        message.Span = reader.readBytes();
                        break;
                    case 12:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Tags as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Request {
            return Request.deserialize(bytes);
        }
    }
    export namespace Request {
        export enum RequestType {
            RequestTypeUnknown = 0,
            Command = 1,
            Query = 2
        }
    }
    export class Response extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ClientID?: string;
            RequestID?: string;
            ReplyChannel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            CacheHit?: boolean;
            Timestamp?: number;
            Executed?: boolean;
            Error?: string;
            Span?: Uint8Array;
            Tags?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("ReplyChannel" in data && data.ReplyChannel != undefined) {
                    this.ReplyChannel = data.ReplyChannel;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
                if ("Body" in data && data.Body != undefined) {
                    this.Body = data.Body;
                }
                if ("CacheHit" in data && data.CacheHit != undefined) {
                    this.CacheHit = data.CacheHit;
                }
                if ("Timestamp" in data && data.Timestamp != undefined) {
                    this.Timestamp = data.Timestamp;
                }
                if ("Executed" in data && data.Executed != undefined) {
                    this.Executed = data.Executed;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
                if ("Span" in data && data.Span != undefined) {
                    this.Span = data.Span;
                }
                if ("Tags" in data && data.Tags != undefined) {
                    this.Tags = data.Tags;
                }
            }
            if (!this.Tags)
                this.Tags = new Map();
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get ReplyChannel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set ReplyChannel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Metadata() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Metadata(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Body() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set Body(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get CacheHit() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set CacheHit(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get Timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Timestamp(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get Executed() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set Executed(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get Span() {
            return pb_1.Message.getFieldWithDefault(this, 10, new Uint8Array(0)) as Uint8Array;
        }
        set Span(value: Uint8Array) {
            pb_1.Message.setField(this, 10, value);
        }
        get Tags() {
            return pb_1.Message.getField(this, 11) as any as Map<string, string>;
        }
        set Tags(value: Map<string, string>) {
            pb_1.Message.setField(this, 11, value as any);
        }
        static fromObject(data: {
            ClientID?: string;
            RequestID?: string;
            ReplyChannel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            CacheHit?: boolean;
            Timestamp?: number;
            Executed?: boolean;
            Error?: string;
            Span?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
        }): Response {
            const message = new Response({});
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.ReplyChannel != null) {
                message.ReplyChannel = data.ReplyChannel;
            }
            if (data.Metadata != null) {
                message.Metadata = data.Metadata;
            }
            if (data.Body != null) {
                message.Body = data.Body;
            }
            if (data.CacheHit != null) {
                message.CacheHit = data.CacheHit;
            }
            if (data.Timestamp != null) {
                message.Timestamp = data.Timestamp;
            }
            if (data.Executed != null) {
                message.Executed = data.Executed;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            if (data.Span != null) {
                message.Span = data.Span;
            }
            if (typeof data.Tags == "object") {
                message.Tags = new Map(Object.entries(data.Tags));
            }
            return message;
        }
        toObject() {
            const data: {
                ClientID?: string;
                RequestID?: string;
                ReplyChannel?: string;
                Metadata?: string;
                Body?: Uint8Array;
                CacheHit?: boolean;
                Timestamp?: number;
                Executed?: boolean;
                Error?: string;
                Span?: Uint8Array;
                Tags?: {
                    [key: string]: string;
                };
            } = {};
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.ReplyChannel != null) {
                data.ReplyChannel = this.ReplyChannel;
            }
            if (this.Metadata != null) {
                data.Metadata = this.Metadata;
            }
            if (this.Body != null) {
                data.Body = this.Body;
            }
            if (this.CacheHit != null) {
                data.CacheHit = this.CacheHit;
            }
            if (this.Timestamp != null) {
                data.Timestamp = this.Timestamp;
            }
            if (this.Executed != null) {
                data.Executed = this.Executed;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            if (this.Span != null) {
                data.Span = this.Span;
            }
            if (this.Tags != null) {
                data.Tags = (Object.fromEntries)(this.Tags);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ClientID.length)
                writer.writeString(1, this.ClientID);
            if (this.RequestID.length)
                writer.writeString(2, this.RequestID);
            if (this.ReplyChannel.length)
                writer.writeString(3, this.ReplyChannel);
            if (this.Metadata.length)
                writer.writeString(4, this.Metadata);
            if (this.Body.length)
                writer.writeBytes(5, this.Body);
            if (this.CacheHit != false)
                writer.writeBool(6, this.CacheHit);
            if (this.Timestamp != 0)
                writer.writeInt64(7, this.Timestamp);
            if (this.Executed != false)
                writer.writeBool(8, this.Executed);
            if (this.Error.length)
                writer.writeString(9, this.Error);
            if (this.Span.length)
                writer.writeBytes(10, this.Span);
            for (const [key, value] of this.Tags) {
                writer.writeMessage(11, this.Tags, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Response {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Response();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ClientID = reader.readString();
                        break;
                    case 2:
                        message.RequestID = reader.readString();
                        break;
                    case 3:
                        message.ReplyChannel = reader.readString();
                        break;
                    case 4:
                        message.Metadata = reader.readString();
                        break;
                    case 5:
                        message.Body = reader.readBytes();
                        break;
                    case 6:
                        message.CacheHit = reader.readBool();
                        break;
                    case 7:
                        message.Timestamp = reader.readInt64();
                        break;
                    case 8:
                        message.Executed = reader.readBool();
                        break;
                    case 9:
                        message.Error = reader.readString();
                        break;
                    case 10:
                        message.Span = reader.readBytes();
                        break;
                    case 11:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Tags as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Response {
            return Response.deserialize(bytes);
        }
    }
    export class QueueMessage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            MessageID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Tags?: Map<string, string>;
            Attributes?: QueueMessageAttributes;
            Policy?: QueueMessagePolicy;
            Topic?: string;
            Partition?: number;
            PartitionKey?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("MessageID" in data && data.MessageID != undefined) {
                    this.MessageID = data.MessageID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
                if ("Body" in data && data.Body != undefined) {
                    this.Body = data.Body;
                }
                if ("Tags" in data && data.Tags != undefined) {
                    this.Tags = data.Tags;
                }
                if ("Attributes" in data && data.Attributes != undefined) {
                    this.Attributes = data.Attributes;
                }
                if ("Policy" in data && data.Policy != undefined) {
                    this.Policy = data.Policy;
                }
                if ("Topic" in data && data.Topic != undefined) {
                    this.Topic = data.Topic;
                }
                if ("Partition" in data && data.Partition != undefined) {
                    this.Partition = data.Partition;
                }
                if ("PartitionKey" in data && data.PartitionKey != undefined) {
                    this.PartitionKey = data.PartitionKey;
                }
            }
            if (!this.Tags)
                this.Tags = new Map();
        }
        get MessageID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set MessageID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get Metadata() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Metadata(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get Body() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set Body(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get Tags() {
            return pb_1.Message.getField(this, 6) as any as Map<string, string>;
        }
        set Tags(value: Map<string, string>) {
            pb_1.Message.setField(this, 6, value as any);
        }
        get Attributes() {
            return pb_1.Message.getWrapperField(this, QueueMessageAttributes, 7) as QueueMessageAttributes;
        }
        set Attributes(value: QueueMessageAttributes) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_Attributes() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get Policy() {
            return pb_1.Message.getWrapperField(this, QueueMessagePolicy, 8) as QueueMessagePolicy;
        }
        set Policy(value: QueueMessagePolicy) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_Policy() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get Topic() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set Topic(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get Partition() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set Partition(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get PartitionKey() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set PartitionKey(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            MessageID?: string;
            ClientID?: string;
            Channel?: string;
            Metadata?: string;
            Body?: Uint8Array;
            Tags?: {
                [key: string]: string;
            };
            Attributes?: ReturnType<typeof QueueMessageAttributes.prototype.toObject>;
            Policy?: ReturnType<typeof QueueMessagePolicy.prototype.toObject>;
            Topic?: string;
            Partition?: number;
            PartitionKey?: string;
        }): QueueMessage {
            const message = new QueueMessage({});
            if (data.MessageID != null) {
                message.MessageID = data.MessageID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.Metadata != null) {
                message.Metadata = data.Metadata;
            }
            if (data.Body != null) {
                message.Body = data.Body;
            }
            if (typeof data.Tags == "object") {
                message.Tags = new Map(Object.entries(data.Tags));
            }
            if (data.Attributes != null) {
                message.Attributes = QueueMessageAttributes.fromObject(data.Attributes);
            }
            if (data.Policy != null) {
                message.Policy = QueueMessagePolicy.fromObject(data.Policy);
            }
            if (data.Topic != null) {
                message.Topic = data.Topic;
            }
            if (data.Partition != null) {
                message.Partition = data.Partition;
            }
            if (data.PartitionKey != null) {
                message.PartitionKey = data.PartitionKey;
            }
            return message;
        }
        toObject() {
            const data: {
                MessageID?: string;
                ClientID?: string;
                Channel?: string;
                Metadata?: string;
                Body?: Uint8Array;
                Tags?: {
                    [key: string]: string;
                };
                Attributes?: ReturnType<typeof QueueMessageAttributes.prototype.toObject>;
                Policy?: ReturnType<typeof QueueMessagePolicy.prototype.toObject>;
                Topic?: string;
                Partition?: number;
                PartitionKey?: string;
            } = {};
            if (this.MessageID != null) {
                data.MessageID = this.MessageID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.Metadata != null) {
                data.Metadata = this.Metadata;
            }
            if (this.Body != null) {
                data.Body = this.Body;
            }
            if (this.Tags != null) {
                data.Tags = (Object.fromEntries)(this.Tags);
            }
            if (this.Attributes != null) {
                data.Attributes = this.Attributes.toObject();
            }
            if (this.Policy != null) {
                data.Policy = this.Policy.toObject();
            }
            if (this.Topic != null) {
                data.Topic = this.Topic;
            }
            if (this.Partition != null) {
                data.Partition = this.Partition;
            }
            if (this.PartitionKey != null) {
                data.PartitionKey = this.PartitionKey;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.MessageID.length)
                writer.writeString(1, this.MessageID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.Channel.length)
                writer.writeString(3, this.Channel);
            if (this.Metadata.length)
                writer.writeString(4, this.Metadata);
            if (this.Body.length)
                writer.writeBytes(5, this.Body);
            for (const [key, value] of this.Tags) {
                writer.writeMessage(6, this.Tags, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (this.has_Attributes)
                writer.writeMessage(7, this.Attributes, () => this.Attributes.serialize(writer));
            if (this.has_Policy)
                writer.writeMessage(8, this.Policy, () => this.Policy.serialize(writer));
            if (this.Topic.length)
                writer.writeString(9, this.Topic);
            if (this.Partition != 0)
                writer.writeInt32(10, this.Partition);
            if (this.PartitionKey.length)
                writer.writeString(11, this.PartitionKey);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.MessageID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.Channel = reader.readString();
                        break;
                    case 4:
                        message.Metadata = reader.readString();
                        break;
                    case 5:
                        message.Body = reader.readBytes();
                        break;
                    case 6:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Tags as any, reader, reader.readString, reader.readString));
                        break;
                    case 7:
                        reader.readMessage(message.Attributes, () => message.Attributes = QueueMessageAttributes.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.Policy, () => message.Policy = QueueMessagePolicy.deserialize(reader));
                        break;
                    case 9:
                        message.Topic = reader.readString();
                        break;
                    case 10:
                        message.Partition = reader.readInt32();
                        break;
                    case 11:
                        message.PartitionKey = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueMessage {
            return QueueMessage.deserialize(bytes);
        }
    }
    export class QueueMessagesBatchRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            BatchID?: string;
            Messages?: QueueMessage[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("BatchID" in data && data.BatchID != undefined) {
                    this.BatchID = data.BatchID;
                }
                if ("Messages" in data && data.Messages != undefined) {
                    this.Messages = data.Messages;
                }
            }
        }
        get BatchID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set BatchID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Messages() {
            return pb_1.Message.getRepeatedWrapperField(this, QueueMessage, 2) as QueueMessage[];
        }
        set Messages(value: QueueMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            BatchID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        }): QueueMessagesBatchRequest {
            const message = new QueueMessagesBatchRequest({});
            if (data.BatchID != null) {
                message.BatchID = data.BatchID;
            }
            if (data.Messages != null) {
                message.Messages = data.Messages.map(item => QueueMessage.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                BatchID?: string;
                Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            } = {};
            if (this.BatchID != null) {
                data.BatchID = this.BatchID;
            }
            if (this.Messages != null) {
                data.Messages = this.Messages.map((item: QueueMessage) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.BatchID.length)
                writer.writeString(1, this.BatchID);
            if (this.Messages.length)
                writer.writeRepeatedMessage(2, this.Messages, (item: QueueMessage) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagesBatchRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueMessagesBatchRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.BatchID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Messages, () => pb_1.Message.addToRepeatedWrapperField(message, 2, QueueMessage.deserialize(reader), QueueMessage));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueMessagesBatchRequest {
            return QueueMessagesBatchRequest.deserialize(bytes);
        }
    }
    export class QueueMessagesBatchResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            BatchID?: string;
            Results?: SendQueueMessageResult[];
            HaveErrors?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("BatchID" in data && data.BatchID != undefined) {
                    this.BatchID = data.BatchID;
                }
                if ("Results" in data && data.Results != undefined) {
                    this.Results = data.Results;
                }
                if ("HaveErrors" in data && data.HaveErrors != undefined) {
                    this.HaveErrors = data.HaveErrors;
                }
            }
        }
        get BatchID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set BatchID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Results() {
            return pb_1.Message.getRepeatedWrapperField(this, SendQueueMessageResult, 2) as SendQueueMessageResult[];
        }
        set Results(value: SendQueueMessageResult[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get HaveErrors() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set HaveErrors(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            BatchID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            HaveErrors?: boolean;
        }): QueueMessagesBatchResponse {
            const message = new QueueMessagesBatchResponse({});
            if (data.BatchID != null) {
                message.BatchID = data.BatchID;
            }
            if (data.Results != null) {
                message.Results = data.Results.map(item => SendQueueMessageResult.fromObject(item));
            }
            if (data.HaveErrors != null) {
                message.HaveErrors = data.HaveErrors;
            }
            return message;
        }
        toObject() {
            const data: {
                BatchID?: string;
                Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
                HaveErrors?: boolean;
            } = {};
            if (this.BatchID != null) {
                data.BatchID = this.BatchID;
            }
            if (this.Results != null) {
                data.Results = this.Results.map((item: SendQueueMessageResult) => item.toObject());
            }
            if (this.HaveErrors != null) {
                data.HaveErrors = this.HaveErrors;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.BatchID.length)
                writer.writeString(1, this.BatchID);
            if (this.Results.length)
                writer.writeRepeatedMessage(2, this.Results, (item: SendQueueMessageResult) => item.serialize(writer));
            if (this.HaveErrors != false)
                writer.writeBool(3, this.HaveErrors);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagesBatchResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueMessagesBatchResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.BatchID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Results, () => pb_1.Message.addToRepeatedWrapperField(message, 2, SendQueueMessageResult.deserialize(reader), SendQueueMessageResult));
                        break;
                    case 3:
                        message.HaveErrors = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueMessagesBatchResponse {
            return QueueMessagesBatchResponse.deserialize(bytes);
        }
    }
    export class QueueMessageAttributes extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Timestamp?: number;
            Sequence?: number;
            MD5OfBody?: string;
            ReceiveCount?: number;
            ReRouted?: boolean;
            ReRoutedFromQueue?: string;
            ExpirationAt?: number;
            DelayedTo?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Timestamp" in data && data.Timestamp != undefined) {
                    this.Timestamp = data.Timestamp;
                }
                if ("Sequence" in data && data.Sequence != undefined) {
                    this.Sequence = data.Sequence;
                }
                if ("MD5OfBody" in data && data.MD5OfBody != undefined) {
                    this.MD5OfBody = data.MD5OfBody;
                }
                if ("ReceiveCount" in data && data.ReceiveCount != undefined) {
                    this.ReceiveCount = data.ReceiveCount;
                }
                if ("ReRouted" in data && data.ReRouted != undefined) {
                    this.ReRouted = data.ReRouted;
                }
                if ("ReRoutedFromQueue" in data && data.ReRoutedFromQueue != undefined) {
                    this.ReRoutedFromQueue = data.ReRoutedFromQueue;
                }
                if ("ExpirationAt" in data && data.ExpirationAt != undefined) {
                    this.ExpirationAt = data.ExpirationAt;
                }
                if ("DelayedTo" in data && data.DelayedTo != undefined) {
                    this.DelayedTo = data.DelayedTo;
                }
            }
        }
        get Timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set Timestamp(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set Sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get MD5OfBody() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set MD5OfBody(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get ReceiveCount() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set ReceiveCount(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get ReRouted() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set ReRouted(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get ReRoutedFromQueue() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set ReRoutedFromQueue(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get ExpirationAt() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set ExpirationAt(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get DelayedTo() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set DelayedTo(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            Timestamp?: number;
            Sequence?: number;
            MD5OfBody?: string;
            ReceiveCount?: number;
            ReRouted?: boolean;
            ReRoutedFromQueue?: string;
            ExpirationAt?: number;
            DelayedTo?: number;
        }): QueueMessageAttributes {
            const message = new QueueMessageAttributes({});
            if (data.Timestamp != null) {
                message.Timestamp = data.Timestamp;
            }
            if (data.Sequence != null) {
                message.Sequence = data.Sequence;
            }
            if (data.MD5OfBody != null) {
                message.MD5OfBody = data.MD5OfBody;
            }
            if (data.ReceiveCount != null) {
                message.ReceiveCount = data.ReceiveCount;
            }
            if (data.ReRouted != null) {
                message.ReRouted = data.ReRouted;
            }
            if (data.ReRoutedFromQueue != null) {
                message.ReRoutedFromQueue = data.ReRoutedFromQueue;
            }
            if (data.ExpirationAt != null) {
                message.ExpirationAt = data.ExpirationAt;
            }
            if (data.DelayedTo != null) {
                message.DelayedTo = data.DelayedTo;
            }
            return message;
        }
        toObject() {
            const data: {
                Timestamp?: number;
                Sequence?: number;
                MD5OfBody?: string;
                ReceiveCount?: number;
                ReRouted?: boolean;
                ReRoutedFromQueue?: string;
                ExpirationAt?: number;
                DelayedTo?: number;
            } = {};
            if (this.Timestamp != null) {
                data.Timestamp = this.Timestamp;
            }
            if (this.Sequence != null) {
                data.Sequence = this.Sequence;
            }
            if (this.MD5OfBody != null) {
                data.MD5OfBody = this.MD5OfBody;
            }
            if (this.ReceiveCount != null) {
                data.ReceiveCount = this.ReceiveCount;
            }
            if (this.ReRouted != null) {
                data.ReRouted = this.ReRouted;
            }
            if (this.ReRoutedFromQueue != null) {
                data.ReRoutedFromQueue = this.ReRoutedFromQueue;
            }
            if (this.ExpirationAt != null) {
                data.ExpirationAt = this.ExpirationAt;
            }
            if (this.DelayedTo != null) {
                data.DelayedTo = this.DelayedTo;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Timestamp != 0)
                writer.writeInt64(1, this.Timestamp);
            if (this.Sequence != 0)
                writer.writeUint64(2, this.Sequence);
            if (this.MD5OfBody.length)
                writer.writeString(3, this.MD5OfBody);
            if (this.ReceiveCount != 0)
                writer.writeInt32(4, this.ReceiveCount);
            if (this.ReRouted != false)
                writer.writeBool(5, this.ReRouted);
            if (this.ReRoutedFromQueue.length)
                writer.writeString(6, this.ReRoutedFromQueue);
            if (this.ExpirationAt != 0)
                writer.writeInt64(7, this.ExpirationAt);
            if (this.DelayedTo != 0)
                writer.writeInt64(8, this.DelayedTo);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessageAttributes {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueMessageAttributes();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Timestamp = reader.readInt64();
                        break;
                    case 2:
                        message.Sequence = reader.readUint64();
                        break;
                    case 3:
                        message.MD5OfBody = reader.readString();
                        break;
                    case 4:
                        message.ReceiveCount = reader.readInt32();
                        break;
                    case 5:
                        message.ReRouted = reader.readBool();
                        break;
                    case 6:
                        message.ReRoutedFromQueue = reader.readString();
                        break;
                    case 7:
                        message.ExpirationAt = reader.readInt64();
                        break;
                    case 8:
                        message.DelayedTo = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueMessageAttributes {
            return QueueMessageAttributes.deserialize(bytes);
        }
    }
    export class QueueMessagePolicy extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ExpirationSeconds?: number;
            DelaySeconds?: number;
            MaxReceiveCount?: number;
            MaxReceiveQueue?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ExpirationSeconds" in data && data.ExpirationSeconds != undefined) {
                    this.ExpirationSeconds = data.ExpirationSeconds;
                }
                if ("DelaySeconds" in data && data.DelaySeconds != undefined) {
                    this.DelaySeconds = data.DelaySeconds;
                }
                if ("MaxReceiveCount" in data && data.MaxReceiveCount != undefined) {
                    this.MaxReceiveCount = data.MaxReceiveCount;
                }
                if ("MaxReceiveQueue" in data && data.MaxReceiveQueue != undefined) {
                    this.MaxReceiveQueue = data.MaxReceiveQueue;
                }
            }
        }
        get ExpirationSeconds() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set ExpirationSeconds(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get DelaySeconds() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set DelaySeconds(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get MaxReceiveCount() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set MaxReceiveCount(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get MaxReceiveQueue() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set MaxReceiveQueue(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            ExpirationSeconds?: number;
            DelaySeconds?: number;
            MaxReceiveCount?: number;
            MaxReceiveQueue?: string;
        }): QueueMessagePolicy {
            const message = new QueueMessagePolicy({});
            if (data.ExpirationSeconds != null) {
                message.ExpirationSeconds = data.ExpirationSeconds;
            }
            if (data.DelaySeconds != null) {
                message.DelaySeconds = data.DelaySeconds;
            }
            if (data.MaxReceiveCount != null) {
                message.MaxReceiveCount = data.MaxReceiveCount;
            }
            if (data.MaxReceiveQueue != null) {
                message.MaxReceiveQueue = data.MaxReceiveQueue;
            }
            return message;
        }
        toObject() {
            const data: {
                ExpirationSeconds?: number;
                DelaySeconds?: number;
                MaxReceiveCount?: number;
                MaxReceiveQueue?: string;
            } = {};
            if (this.ExpirationSeconds != null) {
                data.ExpirationSeconds = this.ExpirationSeconds;
            }
            if (this.DelaySeconds != null) {
                data.DelaySeconds = this.DelaySeconds;
            }
            if (this.MaxReceiveCount != null) {
                data.MaxReceiveCount = this.MaxReceiveCount;
            }
            if (this.MaxReceiveQueue != null) {
                data.MaxReceiveQueue = this.MaxReceiveQueue;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ExpirationSeconds != 0)
                writer.writeInt32(1, this.ExpirationSeconds);
            if (this.DelaySeconds != 0)
                writer.writeInt32(2, this.DelaySeconds);
            if (this.MaxReceiveCount != 0)
                writer.writeInt32(3, this.MaxReceiveCount);
            if (this.MaxReceiveQueue.length)
                writer.writeString(4, this.MaxReceiveQueue);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueMessagePolicy {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueMessagePolicy();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ExpirationSeconds = reader.readInt32();
                        break;
                    case 2:
                        message.DelaySeconds = reader.readInt32();
                        break;
                    case 3:
                        message.MaxReceiveCount = reader.readInt32();
                        break;
                    case 4:
                        message.MaxReceiveQueue = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueMessagePolicy {
            return QueueMessagePolicy.deserialize(bytes);
        }
    }
    export class SendQueueMessageResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            MessageID?: string;
            SentAt?: number;
            ExpirationAt?: number;
            DelayedTo?: number;
            IsError?: boolean;
            Error?: string;
            RefChannel?: string;
            RefTopic?: string;
            RefPartition?: number;
            RefHash?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("MessageID" in data && data.MessageID != undefined) {
                    this.MessageID = data.MessageID;
                }
                if ("SentAt" in data && data.SentAt != undefined) {
                    this.SentAt = data.SentAt;
                }
                if ("ExpirationAt" in data && data.ExpirationAt != undefined) {
                    this.ExpirationAt = data.ExpirationAt;
                }
                if ("DelayedTo" in data && data.DelayedTo != undefined) {
                    this.DelayedTo = data.DelayedTo;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
                if ("RefChannel" in data && data.RefChannel != undefined) {
                    this.RefChannel = data.RefChannel;
                }
                if ("RefTopic" in data && data.RefTopic != undefined) {
                    this.RefTopic = data.RefTopic;
                }
                if ("RefPartition" in data && data.RefPartition != undefined) {
                    this.RefPartition = data.RefPartition;
                }
                if ("RefHash" in data && data.RefHash != undefined) {
                    this.RefHash = data.RefHash;
                }
            }
        }
        get MessageID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set MessageID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get SentAt() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set SentAt(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get ExpirationAt() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set ExpirationAt(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get DelayedTo() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set DelayedTo(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get RefChannel() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set RefChannel(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get RefTopic() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set RefTopic(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get RefPartition() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set RefPartition(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get RefHash() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set RefHash(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            MessageID?: string;
            SentAt?: number;
            ExpirationAt?: number;
            DelayedTo?: number;
            IsError?: boolean;
            Error?: string;
            RefChannel?: string;
            RefTopic?: string;
            RefPartition?: number;
            RefHash?: string;
        }): SendQueueMessageResult {
            const message = new SendQueueMessageResult({});
            if (data.MessageID != null) {
                message.MessageID = data.MessageID;
            }
            if (data.SentAt != null) {
                message.SentAt = data.SentAt;
            }
            if (data.ExpirationAt != null) {
                message.ExpirationAt = data.ExpirationAt;
            }
            if (data.DelayedTo != null) {
                message.DelayedTo = data.DelayedTo;
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            if (data.RefChannel != null) {
                message.RefChannel = data.RefChannel;
            }
            if (data.RefTopic != null) {
                message.RefTopic = data.RefTopic;
            }
            if (data.RefPartition != null) {
                message.RefPartition = data.RefPartition;
            }
            if (data.RefHash != null) {
                message.RefHash = data.RefHash;
            }
            return message;
        }
        toObject() {
            const data: {
                MessageID?: string;
                SentAt?: number;
                ExpirationAt?: number;
                DelayedTo?: number;
                IsError?: boolean;
                Error?: string;
                RefChannel?: string;
                RefTopic?: string;
                RefPartition?: number;
                RefHash?: string;
            } = {};
            if (this.MessageID != null) {
                data.MessageID = this.MessageID;
            }
            if (this.SentAt != null) {
                data.SentAt = this.SentAt;
            }
            if (this.ExpirationAt != null) {
                data.ExpirationAt = this.ExpirationAt;
            }
            if (this.DelayedTo != null) {
                data.DelayedTo = this.DelayedTo;
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            if (this.RefChannel != null) {
                data.RefChannel = this.RefChannel;
            }
            if (this.RefTopic != null) {
                data.RefTopic = this.RefTopic;
            }
            if (this.RefPartition != null) {
                data.RefPartition = this.RefPartition;
            }
            if (this.RefHash != null) {
                data.RefHash = this.RefHash;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.MessageID.length)
                writer.writeString(1, this.MessageID);
            if (this.SentAt != 0)
                writer.writeInt64(2, this.SentAt);
            if (this.ExpirationAt != 0)
                writer.writeInt64(3, this.ExpirationAt);
            if (this.DelayedTo != 0)
                writer.writeInt64(4, this.DelayedTo);
            if (this.IsError != false)
                writer.writeBool(5, this.IsError);
            if (this.Error.length)
                writer.writeString(6, this.Error);
            if (this.RefChannel.length)
                writer.writeString(7, this.RefChannel);
            if (this.RefTopic.length)
                writer.writeString(8, this.RefTopic);
            if (this.RefPartition != 0)
                writer.writeInt32(9, this.RefPartition);
            if (this.RefHash.length)
                writer.writeString(10, this.RefHash);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SendQueueMessageResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SendQueueMessageResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.MessageID = reader.readString();
                        break;
                    case 2:
                        message.SentAt = reader.readInt64();
                        break;
                    case 3:
                        message.ExpirationAt = reader.readInt64();
                        break;
                    case 4:
                        message.DelayedTo = reader.readInt64();
                        break;
                    case 5:
                        message.IsError = reader.readBool();
                        break;
                    case 6:
                        message.Error = reader.readString();
                        break;
                    case 7:
                        message.RefChannel = reader.readString();
                        break;
                    case 8:
                        message.RefTopic = reader.readString();
                        break;
                    case 9:
                        message.RefPartition = reader.readInt32();
                        break;
                    case 10:
                        message.RefHash = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SendQueueMessageResult {
            return SendQueueMessageResult.deserialize(bytes);
        }
    }
    export class ReceiveQueueMessagesRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            MaxNumberOfMessages?: number;
            WaitTimeSeconds?: number;
            IsPeak?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("MaxNumberOfMessages" in data && data.MaxNumberOfMessages != undefined) {
                    this.MaxNumberOfMessages = data.MaxNumberOfMessages;
                }
                if ("WaitTimeSeconds" in data && data.WaitTimeSeconds != undefined) {
                    this.WaitTimeSeconds = data.WaitTimeSeconds;
                }
                if ("IsPeak" in data && data.IsPeak != undefined) {
                    this.IsPeak = data.IsPeak;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get MaxNumberOfMessages() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set MaxNumberOfMessages(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get WaitTimeSeconds() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set WaitTimeSeconds(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get IsPeak() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set IsPeak(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            MaxNumberOfMessages?: number;
            WaitTimeSeconds?: number;
            IsPeak?: boolean;
        }): ReceiveQueueMessagesRequest {
            const message = new ReceiveQueueMessagesRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.MaxNumberOfMessages != null) {
                message.MaxNumberOfMessages = data.MaxNumberOfMessages;
            }
            if (data.WaitTimeSeconds != null) {
                message.WaitTimeSeconds = data.WaitTimeSeconds;
            }
            if (data.IsPeak != null) {
                message.IsPeak = data.IsPeak;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                ClientID?: string;
                Channel?: string;
                MaxNumberOfMessages?: number;
                WaitTimeSeconds?: number;
                IsPeak?: boolean;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.MaxNumberOfMessages != null) {
                data.MaxNumberOfMessages = this.MaxNumberOfMessages;
            }
            if (this.WaitTimeSeconds != null) {
                data.WaitTimeSeconds = this.WaitTimeSeconds;
            }
            if (this.IsPeak != null) {
                data.IsPeak = this.IsPeak;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.Channel.length)
                writer.writeString(3, this.Channel);
            if (this.MaxNumberOfMessages != 0)
                writer.writeInt32(4, this.MaxNumberOfMessages);
            if (this.WaitTimeSeconds != 0)
                writer.writeInt32(5, this.WaitTimeSeconds);
            if (this.IsPeak != false)
                writer.writeBool(6, this.IsPeak);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiveQueueMessagesRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReceiveQueueMessagesRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.Channel = reader.readString();
                        break;
                    case 4:
                        message.MaxNumberOfMessages = reader.readInt32();
                        break;
                    case 5:
                        message.WaitTimeSeconds = reader.readInt32();
                        break;
                    case 6:
                        message.IsPeak = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReceiveQueueMessagesRequest {
            return ReceiveQueueMessagesRequest.deserialize(bytes);
        }
    }
    export class ReceiveQueueMessagesResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            Messages?: QueueMessage[];
            MessagesReceived?: number;
            MessagesExpired?: number;
            IsPeak?: boolean;
            IsError?: boolean;
            Error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("Messages" in data && data.Messages != undefined) {
                    this.Messages = data.Messages;
                }
                if ("MessagesReceived" in data && data.MessagesReceived != undefined) {
                    this.MessagesReceived = data.MessagesReceived;
                }
                if ("MessagesExpired" in data && data.MessagesExpired != undefined) {
                    this.MessagesExpired = data.MessagesExpired;
                }
                if ("IsPeak" in data && data.IsPeak != undefined) {
                    this.IsPeak = data.IsPeak;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Messages() {
            return pb_1.Message.getRepeatedWrapperField(this, QueueMessage, 2) as QueueMessage[];
        }
        set Messages(value: QueueMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get MessagesReceived() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set MessagesReceived(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get MessagesExpired() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set MessagesExpired(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get IsPeak() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set IsPeak(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            MessagesReceived?: number;
            MessagesExpired?: number;
            IsPeak?: boolean;
            IsError?: boolean;
            Error?: string;
        }): ReceiveQueueMessagesResponse {
            const message = new ReceiveQueueMessagesResponse({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.Messages != null) {
                message.Messages = data.Messages.map(item => QueueMessage.fromObject(item));
            }
            if (data.MessagesReceived != null) {
                message.MessagesReceived = data.MessagesReceived;
            }
            if (data.MessagesExpired != null) {
                message.MessagesExpired = data.MessagesExpired;
            }
            if (data.IsPeak != null) {
                message.IsPeak = data.IsPeak;
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
                MessagesReceived?: number;
                MessagesExpired?: number;
                IsPeak?: boolean;
                IsError?: boolean;
                Error?: string;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.Messages != null) {
                data.Messages = this.Messages.map((item: QueueMessage) => item.toObject());
            }
            if (this.MessagesReceived != null) {
                data.MessagesReceived = this.MessagesReceived;
            }
            if (this.MessagesExpired != null) {
                data.MessagesExpired = this.MessagesExpired;
            }
            if (this.IsPeak != null) {
                data.IsPeak = this.IsPeak;
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.Messages.length)
                writer.writeRepeatedMessage(2, this.Messages, (item: QueueMessage) => item.serialize(writer));
            if (this.MessagesReceived != 0)
                writer.writeInt32(3, this.MessagesReceived);
            if (this.MessagesExpired != 0)
                writer.writeInt32(4, this.MessagesExpired);
            if (this.IsPeak != false)
                writer.writeBool(5, this.IsPeak);
            if (this.IsError != false)
                writer.writeBool(6, this.IsError);
            if (this.Error.length)
                writer.writeString(7, this.Error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiveQueueMessagesResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReceiveQueueMessagesResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Messages, () => pb_1.Message.addToRepeatedWrapperField(message, 2, QueueMessage.deserialize(reader), QueueMessage));
                        break;
                    case 3:
                        message.MessagesReceived = reader.readInt32();
                        break;
                    case 4:
                        message.MessagesExpired = reader.readInt32();
                        break;
                    case 5:
                        message.IsPeak = reader.readBool();
                        break;
                    case 6:
                        message.IsError = reader.readBool();
                        break;
                    case 7:
                        message.Error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReceiveQueueMessagesResponse {
            return ReceiveQueueMessagesResponse.deserialize(bytes);
        }
    }
    export class AckAllQueueMessagesRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            WaitTimeSeconds?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("WaitTimeSeconds" in data && data.WaitTimeSeconds != undefined) {
                    this.WaitTimeSeconds = data.WaitTimeSeconds;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get WaitTimeSeconds() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set WaitTimeSeconds(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            Channel?: string;
            WaitTimeSeconds?: number;
        }): AckAllQueueMessagesRequest {
            const message = new AckAllQueueMessagesRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.WaitTimeSeconds != null) {
                message.WaitTimeSeconds = data.WaitTimeSeconds;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                ClientID?: string;
                Channel?: string;
                WaitTimeSeconds?: number;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.WaitTimeSeconds != null) {
                data.WaitTimeSeconds = this.WaitTimeSeconds;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.Channel.length)
                writer.writeString(3, this.Channel);
            if (this.WaitTimeSeconds != 0)
                writer.writeInt32(4, this.WaitTimeSeconds);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AckAllQueueMessagesRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AckAllQueueMessagesRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.Channel = reader.readString();
                        break;
                    case 4:
                        message.WaitTimeSeconds = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AckAllQueueMessagesRequest {
            return AckAllQueueMessagesRequest.deserialize(bytes);
        }
    }
    export class AckAllQueueMessagesResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            AffectedMessages?: number;
            IsError?: boolean;
            Error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("AffectedMessages" in data && data.AffectedMessages != undefined) {
                    this.AffectedMessages = data.AffectedMessages;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get AffectedMessages() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set AffectedMessages(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            RequestID?: string;
            AffectedMessages?: number;
            IsError?: boolean;
            Error?: string;
        }): AckAllQueueMessagesResponse {
            const message = new AckAllQueueMessagesResponse({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.AffectedMessages != null) {
                message.AffectedMessages = data.AffectedMessages;
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                AffectedMessages?: number;
                IsError?: boolean;
                Error?: string;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.AffectedMessages != null) {
                data.AffectedMessages = this.AffectedMessages;
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.AffectedMessages != 0)
                writer.writeUint64(2, this.AffectedMessages);
            if (this.IsError != false)
                writer.writeBool(3, this.IsError);
            if (this.Error.length)
                writer.writeString(4, this.Error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AckAllQueueMessagesResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AckAllQueueMessagesResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.AffectedMessages = reader.readUint64();
                        break;
                    case 3:
                        message.IsError = reader.readBool();
                        break;
                    case 4:
                        message.Error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AckAllQueueMessagesResponse {
            return AckAllQueueMessagesResponse.deserialize(bytes);
        }
    }
    export class StreamQueueMessagesRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Channel?: string;
            VisibilitySeconds?: number;
            WaitTimeSeconds?: number;
            RefSequence?: number;
            ModifiedMessage?: QueueMessage;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("StreamRequestTypeData" in data && data.StreamRequestTypeData != undefined) {
                    this.StreamRequestTypeData = data.StreamRequestTypeData;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("VisibilitySeconds" in data && data.VisibilitySeconds != undefined) {
                    this.VisibilitySeconds = data.VisibilitySeconds;
                }
                if ("WaitTimeSeconds" in data && data.WaitTimeSeconds != undefined) {
                    this.WaitTimeSeconds = data.WaitTimeSeconds;
                }
                if ("RefSequence" in data && data.RefSequence != undefined) {
                    this.RefSequence = data.RefSequence;
                }
                if ("ModifiedMessage" in data && data.ModifiedMessage != undefined) {
                    this.ModifiedMessage = data.ModifiedMessage;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get StreamRequestTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 3, StreamRequestType.StreamRequestTypeUnknown) as StreamRequestType;
        }
        set StreamRequestTypeData(value: StreamRequestType) {
            pb_1.Message.setField(this, 3, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get VisibilitySeconds() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set VisibilitySeconds(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get WaitTimeSeconds() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set WaitTimeSeconds(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get RefSequence() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set RefSequence(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get ModifiedMessage() {
            return pb_1.Message.getWrapperField(this, QueueMessage, 8) as QueueMessage;
        }
        set ModifiedMessage(value: QueueMessage) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_ModifiedMessage() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Channel?: string;
            VisibilitySeconds?: number;
            WaitTimeSeconds?: number;
            RefSequence?: number;
            ModifiedMessage?: ReturnType<typeof QueueMessage.prototype.toObject>;
        }): StreamQueueMessagesRequest {
            const message = new StreamQueueMessagesRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.StreamRequestTypeData != null) {
                message.StreamRequestTypeData = data.StreamRequestTypeData;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.VisibilitySeconds != null) {
                message.VisibilitySeconds = data.VisibilitySeconds;
            }
            if (data.WaitTimeSeconds != null) {
                message.WaitTimeSeconds = data.WaitTimeSeconds;
            }
            if (data.RefSequence != null) {
                message.RefSequence = data.RefSequence;
            }
            if (data.ModifiedMessage != null) {
                message.ModifiedMessage = QueueMessage.fromObject(data.ModifiedMessage);
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                ClientID?: string;
                StreamRequestTypeData?: StreamRequestType;
                Channel?: string;
                VisibilitySeconds?: number;
                WaitTimeSeconds?: number;
                RefSequence?: number;
                ModifiedMessage?: ReturnType<typeof QueueMessage.prototype.toObject>;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.StreamRequestTypeData != null) {
                data.StreamRequestTypeData = this.StreamRequestTypeData;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.VisibilitySeconds != null) {
                data.VisibilitySeconds = this.VisibilitySeconds;
            }
            if (this.WaitTimeSeconds != null) {
                data.WaitTimeSeconds = this.WaitTimeSeconds;
            }
            if (this.RefSequence != null) {
                data.RefSequence = this.RefSequence;
            }
            if (this.ModifiedMessage != null) {
                data.ModifiedMessage = this.ModifiedMessage.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.StreamRequestTypeData != StreamRequestType.StreamRequestTypeUnknown)
                writer.writeEnum(3, this.StreamRequestTypeData);
            if (this.Channel.length)
                writer.writeString(4, this.Channel);
            if (this.VisibilitySeconds != 0)
                writer.writeInt32(5, this.VisibilitySeconds);
            if (this.WaitTimeSeconds != 0)
                writer.writeInt32(6, this.WaitTimeSeconds);
            if (this.RefSequence != 0)
                writer.writeUint64(7, this.RefSequence);
            if (this.has_ModifiedMessage)
                writer.writeMessage(8, this.ModifiedMessage, () => this.ModifiedMessage.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamQueueMessagesRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamQueueMessagesRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.StreamRequestTypeData = reader.readEnum();
                        break;
                    case 4:
                        message.Channel = reader.readString();
                        break;
                    case 5:
                        message.VisibilitySeconds = reader.readInt32();
                        break;
                    case 6:
                        message.WaitTimeSeconds = reader.readInt32();
                        break;
                    case 7:
                        message.RefSequence = reader.readUint64();
                        break;
                    case 8:
                        reader.readMessage(message.ModifiedMessage, () => message.ModifiedMessage = QueueMessage.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StreamQueueMessagesRequest {
            return StreamQueueMessagesRequest.deserialize(bytes);
        }
    }
    export class StreamQueueMessagesResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Message?: QueueMessage;
            IsError?: boolean;
            Error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("StreamRequestTypeData" in data && data.StreamRequestTypeData != undefined) {
                    this.StreamRequestTypeData = data.StreamRequestTypeData;
                }
                if ("Message" in data && data.Message != undefined) {
                    this.Message = data.Message;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get StreamRequestTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 2, StreamRequestType.StreamRequestTypeUnknown) as StreamRequestType;
        }
        set StreamRequestTypeData(value: StreamRequestType) {
            pb_1.Message.setField(this, 2, value);
        }
        get Message() {
            return pb_1.Message.getWrapperField(this, QueueMessage, 3) as QueueMessage;
        }
        set Message(value: QueueMessage) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_Message() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            RequestID?: string;
            StreamRequestTypeData?: StreamRequestType;
            Message?: ReturnType<typeof QueueMessage.prototype.toObject>;
            IsError?: boolean;
            Error?: string;
        }): StreamQueueMessagesResponse {
            const message = new StreamQueueMessagesResponse({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.StreamRequestTypeData != null) {
                message.StreamRequestTypeData = data.StreamRequestTypeData;
            }
            if (data.Message != null) {
                message.Message = QueueMessage.fromObject(data.Message);
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                StreamRequestTypeData?: StreamRequestType;
                Message?: ReturnType<typeof QueueMessage.prototype.toObject>;
                IsError?: boolean;
                Error?: string;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.StreamRequestTypeData != null) {
                data.StreamRequestTypeData = this.StreamRequestTypeData;
            }
            if (this.Message != null) {
                data.Message = this.Message.toObject();
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.StreamRequestTypeData != StreamRequestType.StreamRequestTypeUnknown)
                writer.writeEnum(2, this.StreamRequestTypeData);
            if (this.has_Message)
                writer.writeMessage(3, this.Message, () => this.Message.serialize(writer));
            if (this.IsError != false)
                writer.writeBool(4, this.IsError);
            if (this.Error.length)
                writer.writeString(5, this.Error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StreamQueueMessagesResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StreamQueueMessagesResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.StreamRequestTypeData = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.Message, () => message.Message = QueueMessage.deserialize(reader));
                        break;
                    case 4:
                        message.IsError = reader.readBool();
                        break;
                    case 5:
                        message.Error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StreamQueueMessagesResponse {
            return StreamQueueMessagesResponse.deserialize(bytes);
        }
    }
    export class QueuesUpstreamRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            Messages?: QueueMessage[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("Messages" in data && data.Messages != undefined) {
                    this.Messages = data.Messages;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Messages() {
            return pb_1.Message.getRepeatedWrapperField(this, QueueMessage, 2) as QueueMessage[];
        }
        set Messages(value: QueueMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            RequestID?: string;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
        }): QueuesUpstreamRequest {
            const message = new QueuesUpstreamRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.Messages != null) {
                message.Messages = data.Messages.map(item => QueueMessage.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.Messages != null) {
                data.Messages = this.Messages.map((item: QueueMessage) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.Messages.length)
                writer.writeRepeatedMessage(2, this.Messages, (item: QueueMessage) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesUpstreamRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesUpstreamRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Messages, () => pb_1.Message.addToRepeatedWrapperField(message, 2, QueueMessage.deserialize(reader), QueueMessage));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesUpstreamRequest {
            return QueuesUpstreamRequest.deserialize(bytes);
        }
    }
    export class QueuesUpstreamResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RefRequestID?: string;
            Results?: SendQueueMessageResult[];
            IsError?: boolean;
            Error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RefRequestID" in data && data.RefRequestID != undefined) {
                    this.RefRequestID = data.RefRequestID;
                }
                if ("Results" in data && data.Results != undefined) {
                    this.Results = data.Results;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
            }
        }
        get RefRequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RefRequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Results() {
            return pb_1.Message.getRepeatedWrapperField(this, SendQueueMessageResult, 2) as SendQueueMessageResult[];
        }
        set Results(value: SendQueueMessageResult[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            RefRequestID?: string;
            Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
            IsError?: boolean;
            Error?: string;
        }): QueuesUpstreamResponse {
            const message = new QueuesUpstreamResponse({});
            if (data.RefRequestID != null) {
                message.RefRequestID = data.RefRequestID;
            }
            if (data.Results != null) {
                message.Results = data.Results.map(item => SendQueueMessageResult.fromObject(item));
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            return message;
        }
        toObject() {
            const data: {
                RefRequestID?: string;
                Results?: ReturnType<typeof SendQueueMessageResult.prototype.toObject>[];
                IsError?: boolean;
                Error?: string;
            } = {};
            if (this.RefRequestID != null) {
                data.RefRequestID = this.RefRequestID;
            }
            if (this.Results != null) {
                data.Results = this.Results.map((item: SendQueueMessageResult) => item.toObject());
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RefRequestID.length)
                writer.writeString(1, this.RefRequestID);
            if (this.Results.length)
                writer.writeRepeatedMessage(2, this.Results, (item: SendQueueMessageResult) => item.serialize(writer));
            if (this.IsError != false)
                writer.writeBool(3, this.IsError);
            if (this.Error.length)
                writer.writeString(4, this.Error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesUpstreamResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesUpstreamResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RefRequestID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Results, () => pb_1.Message.addToRepeatedWrapperField(message, 2, SendQueueMessageResult.deserialize(reader), SendQueueMessageResult));
                        break;
                    case 3:
                        message.IsError = reader.readBool();
                        break;
                    case 4:
                        message.Error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesUpstreamResponse {
            return QueuesUpstreamResponse.deserialize(bytes);
        }
    }
    export class QueuesDownstreamRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            ClientID?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Channel?: string;
            MaxItems?: number;
            WaitTimeout?: number;
            AutoAck?: boolean;
            ReQueueChannel?: string;
            SequenceRange?: number[];
            RefTransactionId?: string;
            Metadata?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("ClientID" in data && data.ClientID != undefined) {
                    this.ClientID = data.ClientID;
                }
                if ("RequestTypeData" in data && data.RequestTypeData != undefined) {
                    this.RequestTypeData = data.RequestTypeData;
                }
                if ("Channel" in data && data.Channel != undefined) {
                    this.Channel = data.Channel;
                }
                if ("MaxItems" in data && data.MaxItems != undefined) {
                    this.MaxItems = data.MaxItems;
                }
                if ("WaitTimeout" in data && data.WaitTimeout != undefined) {
                    this.WaitTimeout = data.WaitTimeout;
                }
                if ("AutoAck" in data && data.AutoAck != undefined) {
                    this.AutoAck = data.AutoAck;
                }
                if ("ReQueueChannel" in data && data.ReQueueChannel != undefined) {
                    this.ReQueueChannel = data.ReQueueChannel;
                }
                if ("SequenceRange" in data && data.SequenceRange != undefined) {
                    this.SequenceRange = data.SequenceRange;
                }
                if ("RefTransactionId" in data && data.RefTransactionId != undefined) {
                    this.RefTransactionId = data.RefTransactionId;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
            }
            if (!this.Metadata)
                this.Metadata = new Map();
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get ClientID() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set ClientID(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get RequestTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 3, QueuesDownstreamRequestType.PollRequestTypeUnknown) as QueuesDownstreamRequestType;
        }
        set RequestTypeData(value: QueuesDownstreamRequestType) {
            pb_1.Message.setField(this, 3, value);
        }
        get Channel() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set Channel(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get MaxItems() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set MaxItems(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get WaitTimeout() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set WaitTimeout(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get AutoAck() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set AutoAck(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get ReQueueChannel() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set ReQueueChannel(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get SequenceRange() {
            return pb_1.Message.getFieldWithDefault(this, 9, []) as number[];
        }
        set SequenceRange(value: number[]) {
            pb_1.Message.setField(this, 9, value);
        }
        get RefTransactionId() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set RefTransactionId(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get Metadata() {
            return pb_1.Message.getField(this, 12) as any as Map<string, string>;
        }
        set Metadata(value: Map<string, string>) {
            pb_1.Message.setField(this, 12, value as any);
        }
        static fromObject(data: {
            RequestID?: string;
            ClientID?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Channel?: string;
            MaxItems?: number;
            WaitTimeout?: number;
            AutoAck?: boolean;
            ReQueueChannel?: string;
            SequenceRange?: number[];
            RefTransactionId?: string;
            Metadata?: {
                [key: string]: string;
            };
        }): QueuesDownstreamRequest {
            const message = new QueuesDownstreamRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.ClientID != null) {
                message.ClientID = data.ClientID;
            }
            if (data.RequestTypeData != null) {
                message.RequestTypeData = data.RequestTypeData;
            }
            if (data.Channel != null) {
                message.Channel = data.Channel;
            }
            if (data.MaxItems != null) {
                message.MaxItems = data.MaxItems;
            }
            if (data.WaitTimeout != null) {
                message.WaitTimeout = data.WaitTimeout;
            }
            if (data.AutoAck != null) {
                message.AutoAck = data.AutoAck;
            }
            if (data.ReQueueChannel != null) {
                message.ReQueueChannel = data.ReQueueChannel;
            }
            if (data.SequenceRange != null) {
                message.SequenceRange = data.SequenceRange;
            }
            if (data.RefTransactionId != null) {
                message.RefTransactionId = data.RefTransactionId;
            }
            if (typeof data.Metadata == "object") {
                message.Metadata = new Map(Object.entries(data.Metadata));
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                ClientID?: string;
                RequestTypeData?: QueuesDownstreamRequestType;
                Channel?: string;
                MaxItems?: number;
                WaitTimeout?: number;
                AutoAck?: boolean;
                ReQueueChannel?: string;
                SequenceRange?: number[];
                RefTransactionId?: string;
                Metadata?: {
                    [key: string]: string;
                };
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.ClientID != null) {
                data.ClientID = this.ClientID;
            }
            if (this.RequestTypeData != null) {
                data.RequestTypeData = this.RequestTypeData;
            }
            if (this.Channel != null) {
                data.Channel = this.Channel;
            }
            if (this.MaxItems != null) {
                data.MaxItems = this.MaxItems;
            }
            if (this.WaitTimeout != null) {
                data.WaitTimeout = this.WaitTimeout;
            }
            if (this.AutoAck != null) {
                data.AutoAck = this.AutoAck;
            }
            if (this.ReQueueChannel != null) {
                data.ReQueueChannel = this.ReQueueChannel;
            }
            if (this.SequenceRange != null) {
                data.SequenceRange = this.SequenceRange;
            }
            if (this.RefTransactionId != null) {
                data.RefTransactionId = this.RefTransactionId;
            }
            if (this.Metadata != null) {
                data.Metadata = (Object.fromEntries)(this.Metadata);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.ClientID.length)
                writer.writeString(2, this.ClientID);
            if (this.RequestTypeData != QueuesDownstreamRequestType.PollRequestTypeUnknown)
                writer.writeEnum(3, this.RequestTypeData);
            if (this.Channel.length)
                writer.writeString(4, this.Channel);
            if (this.MaxItems != 0)
                writer.writeInt32(5, this.MaxItems);
            if (this.WaitTimeout != 0)
                writer.writeInt32(6, this.WaitTimeout);
            if (this.AutoAck != false)
                writer.writeBool(7, this.AutoAck);
            if (this.ReQueueChannel.length)
                writer.writeString(8, this.ReQueueChannel);
            if (this.SequenceRange.length)
                writer.writePackedInt64(9, this.SequenceRange);
            if (this.RefTransactionId.length)
                writer.writeString(10, this.RefTransactionId);
            for (const [key, value] of this.Metadata) {
                writer.writeMessage(12, this.Metadata, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesDownstreamRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesDownstreamRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.ClientID = reader.readString();
                        break;
                    case 3:
                        message.RequestTypeData = reader.readEnum();
                        break;
                    case 4:
                        message.Channel = reader.readString();
                        break;
                    case 5:
                        message.MaxItems = reader.readInt32();
                        break;
                    case 6:
                        message.WaitTimeout = reader.readInt32();
                        break;
                    case 7:
                        message.AutoAck = reader.readBool();
                        break;
                    case 8:
                        message.ReQueueChannel = reader.readString();
                        break;
                    case 9:
                        message.SequenceRange = reader.readPackedInt64();
                        break;
                    case 10:
                        message.RefTransactionId = reader.readString();
                        break;
                    case 12:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Metadata as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesDownstreamRequest {
            return QueuesDownstreamRequest.deserialize(bytes);
        }
    }
    export class QueuesDownstreamResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            TransactionId?: string;
            RefRequestId?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Messages?: QueueMessage[];
            ActiveOffsets?: number[];
            IsError?: boolean;
            Error?: string;
            TransactionComplete?: boolean;
            Metadata?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("TransactionId" in data && data.TransactionId != undefined) {
                    this.TransactionId = data.TransactionId;
                }
                if ("RefRequestId" in data && data.RefRequestId != undefined) {
                    this.RefRequestId = data.RefRequestId;
                }
                if ("RequestTypeData" in data && data.RequestTypeData != undefined) {
                    this.RequestTypeData = data.RequestTypeData;
                }
                if ("Messages" in data && data.Messages != undefined) {
                    this.Messages = data.Messages;
                }
                if ("ActiveOffsets" in data && data.ActiveOffsets != undefined) {
                    this.ActiveOffsets = data.ActiveOffsets;
                }
                if ("IsError" in data && data.IsError != undefined) {
                    this.IsError = data.IsError;
                }
                if ("Error" in data && data.Error != undefined) {
                    this.Error = data.Error;
                }
                if ("TransactionComplete" in data && data.TransactionComplete != undefined) {
                    this.TransactionComplete = data.TransactionComplete;
                }
                if ("Metadata" in data && data.Metadata != undefined) {
                    this.Metadata = data.Metadata;
                }
            }
            if (!this.Metadata)
                this.Metadata = new Map();
        }
        get TransactionId() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set TransactionId(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get RefRequestId() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set RefRequestId(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get RequestTypeData() {
            return pb_1.Message.getFieldWithDefault(this, 3, QueuesDownstreamRequestType.PollRequestTypeUnknown) as QueuesDownstreamRequestType;
        }
        set RequestTypeData(value: QueuesDownstreamRequestType) {
            pb_1.Message.setField(this, 3, value);
        }
        get Messages() {
            return pb_1.Message.getRepeatedWrapperField(this, QueueMessage, 4) as QueueMessage[];
        }
        set Messages(value: QueueMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get ActiveOffsets() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as number[];
        }
        set ActiveOffsets(value: number[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get IsError() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set IsError(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get Error() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set Error(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get TransactionComplete() {
            return pb_1.Message.getFieldWithDefault(this, 8, false) as boolean;
        }
        set TransactionComplete(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get Metadata() {
            return pb_1.Message.getField(this, 9) as any as Map<string, string>;
        }
        set Metadata(value: Map<string, string>) {
            pb_1.Message.setField(this, 9, value as any);
        }
        static fromObject(data: {
            TransactionId?: string;
            RefRequestId?: string;
            RequestTypeData?: QueuesDownstreamRequestType;
            Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
            ActiveOffsets?: number[];
            IsError?: boolean;
            Error?: string;
            TransactionComplete?: boolean;
            Metadata?: {
                [key: string]: string;
            };
        }): QueuesDownstreamResponse {
            const message = new QueuesDownstreamResponse({});
            if (data.TransactionId != null) {
                message.TransactionId = data.TransactionId;
            }
            if (data.RefRequestId != null) {
                message.RefRequestId = data.RefRequestId;
            }
            if (data.RequestTypeData != null) {
                message.RequestTypeData = data.RequestTypeData;
            }
            if (data.Messages != null) {
                message.Messages = data.Messages.map(item => QueueMessage.fromObject(item));
            }
            if (data.ActiveOffsets != null) {
                message.ActiveOffsets = data.ActiveOffsets;
            }
            if (data.IsError != null) {
                message.IsError = data.IsError;
            }
            if (data.Error != null) {
                message.Error = data.Error;
            }
            if (data.TransactionComplete != null) {
                message.TransactionComplete = data.TransactionComplete;
            }
            if (typeof data.Metadata == "object") {
                message.Metadata = new Map(Object.entries(data.Metadata));
            }
            return message;
        }
        toObject() {
            const data: {
                TransactionId?: string;
                RefRequestId?: string;
                RequestTypeData?: QueuesDownstreamRequestType;
                Messages?: ReturnType<typeof QueueMessage.prototype.toObject>[];
                ActiveOffsets?: number[];
                IsError?: boolean;
                Error?: string;
                TransactionComplete?: boolean;
                Metadata?: {
                    [key: string]: string;
                };
            } = {};
            if (this.TransactionId != null) {
                data.TransactionId = this.TransactionId;
            }
            if (this.RefRequestId != null) {
                data.RefRequestId = this.RefRequestId;
            }
            if (this.RequestTypeData != null) {
                data.RequestTypeData = this.RequestTypeData;
            }
            if (this.Messages != null) {
                data.Messages = this.Messages.map((item: QueueMessage) => item.toObject());
            }
            if (this.ActiveOffsets != null) {
                data.ActiveOffsets = this.ActiveOffsets;
            }
            if (this.IsError != null) {
                data.IsError = this.IsError;
            }
            if (this.Error != null) {
                data.Error = this.Error;
            }
            if (this.TransactionComplete != null) {
                data.TransactionComplete = this.TransactionComplete;
            }
            if (this.Metadata != null) {
                data.Metadata = (Object.fromEntries)(this.Metadata);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.TransactionId.length)
                writer.writeString(1, this.TransactionId);
            if (this.RefRequestId.length)
                writer.writeString(2, this.RefRequestId);
            if (this.RequestTypeData != QueuesDownstreamRequestType.PollRequestTypeUnknown)
                writer.writeEnum(3, this.RequestTypeData);
            if (this.Messages.length)
                writer.writeRepeatedMessage(4, this.Messages, (item: QueueMessage) => item.serialize(writer));
            if (this.ActiveOffsets.length)
                writer.writePackedInt64(5, this.ActiveOffsets);
            if (this.IsError != false)
                writer.writeBool(6, this.IsError);
            if (this.Error.length)
                writer.writeString(7, this.Error);
            if (this.TransactionComplete != false)
                writer.writeBool(8, this.TransactionComplete);
            for (const [key, value] of this.Metadata) {
                writer.writeMessage(9, this.Metadata, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesDownstreamResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesDownstreamResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.TransactionId = reader.readString();
                        break;
                    case 2:
                        message.RefRequestId = reader.readString();
                        break;
                    case 3:
                        message.RequestTypeData = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.Messages, () => pb_1.Message.addToRepeatedWrapperField(message, 4, QueueMessage.deserialize(reader), QueueMessage));
                        break;
                    case 5:
                        message.ActiveOffsets = reader.readPackedInt64();
                        break;
                    case 6:
                        message.IsError = reader.readBool();
                        break;
                    case 7:
                        message.Error = reader.readString();
                        break;
                    case 8:
                        message.TransactionComplete = reader.readBool();
                        break;
                    case 9:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.Metadata as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesDownstreamResponse {
            return QueuesDownstreamResponse.deserialize(bytes);
        }
    }
    export class QueueInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            Name?: string;
            Messages?: number;
            Bytes?: number;
            FirstSequence?: number;
            LastSequence?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Subscribers?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("Name" in data && data.Name != undefined) {
                    this.Name = data.Name;
                }
                if ("Messages" in data && data.Messages != undefined) {
                    this.Messages = data.Messages;
                }
                if ("Bytes" in data && data.Bytes != undefined) {
                    this.Bytes = data.Bytes;
                }
                if ("FirstSequence" in data && data.FirstSequence != undefined) {
                    this.FirstSequence = data.FirstSequence;
                }
                if ("LastSequence" in data && data.LastSequence != undefined) {
                    this.LastSequence = data.LastSequence;
                }
                if ("Sent" in data && data.Sent != undefined) {
                    this.Sent = data.Sent;
                }
                if ("Delivered" in data && data.Delivered != undefined) {
                    this.Delivered = data.Delivered;
                }
                if ("Waiting" in data && data.Waiting != undefined) {
                    this.Waiting = data.Waiting;
                }
                if ("Subscribers" in data && data.Subscribers != undefined) {
                    this.Subscribers = data.Subscribers;
                }
            }
        }
        get Name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set Name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Messages() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set Messages(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get Bytes() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set Bytes(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get FirstSequence() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set FirstSequence(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get LastSequence() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set LastSequence(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get Sent() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set Sent(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get Delivered() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set Delivered(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get Waiting() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set Waiting(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get Subscribers() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set Subscribers(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            Name?: string;
            Messages?: number;
            Bytes?: number;
            FirstSequence?: number;
            LastSequence?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Subscribers?: number;
        }): QueueInfo {
            const message = new QueueInfo({});
            if (data.Name != null) {
                message.Name = data.Name;
            }
            if (data.Messages != null) {
                message.Messages = data.Messages;
            }
            if (data.Bytes != null) {
                message.Bytes = data.Bytes;
            }
            if (data.FirstSequence != null) {
                message.FirstSequence = data.FirstSequence;
            }
            if (data.LastSequence != null) {
                message.LastSequence = data.LastSequence;
            }
            if (data.Sent != null) {
                message.Sent = data.Sent;
            }
            if (data.Delivered != null) {
                message.Delivered = data.Delivered;
            }
            if (data.Waiting != null) {
                message.Waiting = data.Waiting;
            }
            if (data.Subscribers != null) {
                message.Subscribers = data.Subscribers;
            }
            return message;
        }
        toObject() {
            const data: {
                Name?: string;
                Messages?: number;
                Bytes?: number;
                FirstSequence?: number;
                LastSequence?: number;
                Sent?: number;
                Delivered?: number;
                Waiting?: number;
                Subscribers?: number;
            } = {};
            if (this.Name != null) {
                data.Name = this.Name;
            }
            if (this.Messages != null) {
                data.Messages = this.Messages;
            }
            if (this.Bytes != null) {
                data.Bytes = this.Bytes;
            }
            if (this.FirstSequence != null) {
                data.FirstSequence = this.FirstSequence;
            }
            if (this.LastSequence != null) {
                data.LastSequence = this.LastSequence;
            }
            if (this.Sent != null) {
                data.Sent = this.Sent;
            }
            if (this.Delivered != null) {
                data.Delivered = this.Delivered;
            }
            if (this.Waiting != null) {
                data.Waiting = this.Waiting;
            }
            if (this.Subscribers != null) {
                data.Subscribers = this.Subscribers;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.Name.length)
                writer.writeString(1, this.Name);
            if (this.Messages != 0)
                writer.writeInt64(2, this.Messages);
            if (this.Bytes != 0)
                writer.writeInt64(3, this.Bytes);
            if (this.FirstSequence != 0)
                writer.writeInt64(4, this.FirstSequence);
            if (this.LastSequence != 0)
                writer.writeInt64(5, this.LastSequence);
            if (this.Sent != 0)
                writer.writeInt64(6, this.Sent);
            if (this.Delivered != 0)
                writer.writeInt64(7, this.Delivered);
            if (this.Waiting != 0)
                writer.writeInt64(8, this.Waiting);
            if (this.Subscribers != 0)
                writer.writeInt64(9, this.Subscribers);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueueInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueueInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.Name = reader.readString();
                        break;
                    case 2:
                        message.Messages = reader.readInt64();
                        break;
                    case 3:
                        message.Bytes = reader.readInt64();
                        break;
                    case 4:
                        message.FirstSequence = reader.readInt64();
                        break;
                    case 5:
                        message.LastSequence = reader.readInt64();
                        break;
                    case 6:
                        message.Sent = reader.readInt64();
                        break;
                    case 7:
                        message.Delivered = reader.readInt64();
                        break;
                    case 8:
                        message.Waiting = reader.readInt64();
                        break;
                    case 9:
                        message.Subscribers = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueueInfo {
            return QueueInfo.deserialize(bytes);
        }
    }
    export class QueuesInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            TotalQueue?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Queues?: QueueInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("TotalQueue" in data && data.TotalQueue != undefined) {
                    this.TotalQueue = data.TotalQueue;
                }
                if ("Sent" in data && data.Sent != undefined) {
                    this.Sent = data.Sent;
                }
                if ("Delivered" in data && data.Delivered != undefined) {
                    this.Delivered = data.Delivered;
                }
                if ("Waiting" in data && data.Waiting != undefined) {
                    this.Waiting = data.Waiting;
                }
                if ("Queues" in data && data.Queues != undefined) {
                    this.Queues = data.Queues;
                }
            }
        }
        get TotalQueue() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set TotalQueue(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get Sent() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set Sent(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get Delivered() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set Delivered(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get Waiting() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set Waiting(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get Queues() {
            return pb_1.Message.getRepeatedWrapperField(this, QueueInfo, 5) as QueueInfo[];
        }
        set Queues(value: QueueInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        static fromObject(data: {
            TotalQueue?: number;
            Sent?: number;
            Delivered?: number;
            Waiting?: number;
            Queues?: ReturnType<typeof QueueInfo.prototype.toObject>[];
        }): QueuesInfo {
            const message = new QueuesInfo({});
            if (data.TotalQueue != null) {
                message.TotalQueue = data.TotalQueue;
            }
            if (data.Sent != null) {
                message.Sent = data.Sent;
            }
            if (data.Delivered != null) {
                message.Delivered = data.Delivered;
            }
            if (data.Waiting != null) {
                message.Waiting = data.Waiting;
            }
            if (data.Queues != null) {
                message.Queues = data.Queues.map(item => QueueInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                TotalQueue?: number;
                Sent?: number;
                Delivered?: number;
                Waiting?: number;
                Queues?: ReturnType<typeof QueueInfo.prototype.toObject>[];
            } = {};
            if (this.TotalQueue != null) {
                data.TotalQueue = this.TotalQueue;
            }
            if (this.Sent != null) {
                data.Sent = this.Sent;
            }
            if (this.Delivered != null) {
                data.Delivered = this.Delivered;
            }
            if (this.Waiting != null) {
                data.Waiting = this.Waiting;
            }
            if (this.Queues != null) {
                data.Queues = this.Queues.map((item: QueueInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.TotalQueue != 0)
                writer.writeInt32(1, this.TotalQueue);
            if (this.Sent != 0)
                writer.writeInt64(2, this.Sent);
            if (this.Delivered != 0)
                writer.writeInt64(3, this.Delivered);
            if (this.Waiting != 0)
                writer.writeInt64(4, this.Waiting);
            if (this.Queues.length)
                writer.writeRepeatedMessage(5, this.Queues, (item: QueueInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.TotalQueue = reader.readInt32();
                        break;
                    case 2:
                        message.Sent = reader.readInt64();
                        break;
                    case 3:
                        message.Delivered = reader.readInt64();
                        break;
                    case 4:
                        message.Waiting = reader.readInt64();
                        break;
                    case 5:
                        reader.readMessage(message.Queues, () => pb_1.Message.addToRepeatedWrapperField(message, 5, QueueInfo.deserialize(reader), QueueInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesInfo {
            return QueuesInfo.deserialize(bytes);
        }
    }
    export class QueuesInfoRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RequestID?: string;
            QueueName?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RequestID" in data && data.RequestID != undefined) {
                    this.RequestID = data.RequestID;
                }
                if ("QueueName" in data && data.QueueName != undefined) {
                    this.QueueName = data.QueueName;
                }
            }
        }
        get RequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get QueueName() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set QueueName(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            RequestID?: string;
            QueueName?: string;
        }): QueuesInfoRequest {
            const message = new QueuesInfoRequest({});
            if (data.RequestID != null) {
                message.RequestID = data.RequestID;
            }
            if (data.QueueName != null) {
                message.QueueName = data.QueueName;
            }
            return message;
        }
        toObject() {
            const data: {
                RequestID?: string;
                QueueName?: string;
            } = {};
            if (this.RequestID != null) {
                data.RequestID = this.RequestID;
            }
            if (this.QueueName != null) {
                data.QueueName = this.QueueName;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RequestID.length)
                writer.writeString(1, this.RequestID);
            if (this.QueueName.length)
                writer.writeString(2, this.QueueName);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfoRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesInfoRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RequestID = reader.readString();
                        break;
                    case 2:
                        message.QueueName = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesInfoRequest {
            return QueuesInfoRequest.deserialize(bytes);
        }
    }
    export class QueuesInfoResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            RefRequestID?: string;
            Info?: QueuesInfo;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("RefRequestID" in data && data.RefRequestID != undefined) {
                    this.RefRequestID = data.RefRequestID;
                }
                if ("Info" in data && data.Info != undefined) {
                    this.Info = data.Info;
                }
            }
        }
        get RefRequestID() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set RefRequestID(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get Info() {
            return pb_1.Message.getWrapperField(this, QueuesInfo, 2) as QueuesInfo;
        }
        set Info(value: QueuesInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_Info() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            RefRequestID?: string;
            Info?: ReturnType<typeof QueuesInfo.prototype.toObject>;
        }): QueuesInfoResponse {
            const message = new QueuesInfoResponse({});
            if (data.RefRequestID != null) {
                message.RefRequestID = data.RefRequestID;
            }
            if (data.Info != null) {
                message.Info = QueuesInfo.fromObject(data.Info);
            }
            return message;
        }
        toObject() {
            const data: {
                RefRequestID?: string;
                Info?: ReturnType<typeof QueuesInfo.prototype.toObject>;
            } = {};
            if (this.RefRequestID != null) {
                data.RefRequestID = this.RefRequestID;
            }
            if (this.Info != null) {
                data.Info = this.Info.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.RefRequestID.length)
                writer.writeString(1, this.RefRequestID);
            if (this.has_Info)
                writer.writeMessage(2, this.Info, () => this.Info.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueuesInfoResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueuesInfoResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.RefRequestID = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.Info, () => message.Info = QueuesInfo.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueuesInfoResponse {
            return QueuesInfoResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedkubemqService {
        static definition = {
            SendEvent: {
                path: "/kubemq.kubemq/SendEvent",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Event) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Event.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Result) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Result.deserialize(new Uint8Array(bytes))
            },
            SendEventsStream: {
                path: "/kubemq.kubemq/SendEventsStream",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: Event) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Event.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Result) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Result.deserialize(new Uint8Array(bytes))
            },
            SubscribeToEvents: {
                path: "/kubemq.kubemq/SubscribeToEvents",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: Subscribe) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Subscribe.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: EventReceive) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => EventReceive.deserialize(new Uint8Array(bytes))
            },
            SubscribeToRequests: {
                path: "/kubemq.kubemq/SubscribeToRequests",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: Subscribe) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Subscribe.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Request) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Request.deserialize(new Uint8Array(bytes))
            },
            SendRequest: {
                path: "/kubemq.kubemq/SendRequest",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Request) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Request.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Response) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Response.deserialize(new Uint8Array(bytes))
            },
            SendResponse: {
                path: "/kubemq.kubemq/SendResponse",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Response) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Response.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Empty) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Empty.deserialize(new Uint8Array(bytes))
            },
            SendQueueMessage: {
                path: "/kubemq.kubemq/SendQueueMessage",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: QueueMessage) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => QueueMessage.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SendQueueMessageResult) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SendQueueMessageResult.deserialize(new Uint8Array(bytes))
            },
            SendQueueMessagesBatch: {
                path: "/kubemq.kubemq/SendQueueMessagesBatch",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: QueueMessagesBatchRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => QueueMessagesBatchRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: QueueMessagesBatchResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => QueueMessagesBatchResponse.deserialize(new Uint8Array(bytes))
            },
            ReceiveQueueMessages: {
                path: "/kubemq.kubemq/ReceiveQueueMessages",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ReceiveQueueMessagesRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ReceiveQueueMessagesRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ReceiveQueueMessagesResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ReceiveQueueMessagesResponse.deserialize(new Uint8Array(bytes))
            },
            StreamQueueMessage: {
                path: "/kubemq.kubemq/StreamQueueMessage",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: StreamQueueMessagesRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => StreamQueueMessagesRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: StreamQueueMessagesResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => StreamQueueMessagesResponse.deserialize(new Uint8Array(bytes))
            },
            AckAllQueueMessages: {
                path: "/kubemq.kubemq/AckAllQueueMessages",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: AckAllQueueMessagesRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => AckAllQueueMessagesRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: AckAllQueueMessagesResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => AckAllQueueMessagesResponse.deserialize(new Uint8Array(bytes))
            },
            Ping: {
                path: "/kubemq.kubemq/Ping",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Empty) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Empty.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PingResult) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PingResult.deserialize(new Uint8Array(bytes))
            },
            QueuesDownstream: {
                path: "/kubemq.kubemq/QueuesDownstream",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: QueuesDownstreamRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => QueuesDownstreamRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: QueuesDownstreamResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => QueuesDownstreamResponse.deserialize(new Uint8Array(bytes))
            },
            QueuesUpstream: {
                path: "/kubemq.kubemq/QueuesUpstream",
                requestStream: true,
                responseStream: true,
                requestSerialize: (message: QueuesUpstreamRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => QueuesUpstreamRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: QueuesUpstreamResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => QueuesUpstreamResponse.deserialize(new Uint8Array(bytes))
            },
            QueuesInfo: {
                path: "/kubemq.kubemq/QueuesInfo",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: QueuesInfoRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => QueuesInfoRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: QueuesInfoResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => QueuesInfoResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract SendEvent(call: grpc_1.ServerUnaryCall<Event, Result>, callback: grpc_1.sendUnaryData<Result>): void;
        abstract SendEventsStream(call: grpc_1.ServerDuplexStream<Event, Result>): void;
        abstract SubscribeToEvents(call: grpc_1.ServerWritableStream<Subscribe, EventReceive>): void;
        abstract SubscribeToRequests(call: grpc_1.ServerWritableStream<Subscribe, Request>): void;
        abstract SendRequest(call: grpc_1.ServerUnaryCall<Request, Response>, callback: grpc_1.sendUnaryData<Response>): void;
        abstract SendResponse(call: grpc_1.ServerUnaryCall<Response, Empty>, callback: grpc_1.sendUnaryData<Empty>): void;
        abstract SendQueueMessage(call: grpc_1.ServerUnaryCall<QueueMessage, SendQueueMessageResult>, callback: grpc_1.sendUnaryData<SendQueueMessageResult>): void;
        abstract SendQueueMessagesBatch(call: grpc_1.ServerUnaryCall<QueueMessagesBatchRequest, QueueMessagesBatchResponse>, callback: grpc_1.sendUnaryData<QueueMessagesBatchResponse>): void;
        abstract ReceiveQueueMessages(call: grpc_1.ServerUnaryCall<ReceiveQueueMessagesRequest, ReceiveQueueMessagesResponse>, callback: grpc_1.sendUnaryData<ReceiveQueueMessagesResponse>): void;
        abstract StreamQueueMessage(call: grpc_1.ServerDuplexStream<StreamQueueMessagesRequest, StreamQueueMessagesResponse>): void;
        abstract AckAllQueueMessages(call: grpc_1.ServerUnaryCall<AckAllQueueMessagesRequest, AckAllQueueMessagesResponse>, callback: grpc_1.sendUnaryData<AckAllQueueMessagesResponse>): void;
        abstract Ping(call: grpc_1.ServerUnaryCall<Empty, PingResult>, callback: grpc_1.sendUnaryData<PingResult>): void;
        abstract QueuesDownstream(call: grpc_1.ServerDuplexStream<QueuesDownstreamRequest, QueuesDownstreamResponse>): void;
        abstract QueuesUpstream(call: grpc_1.ServerDuplexStream<QueuesUpstreamRequest, QueuesUpstreamResponse>): void;
        abstract QueuesInfo(call: grpc_1.ServerUnaryCall<QueuesInfoRequest, QueuesInfoResponse>, callback: grpc_1.sendUnaryData<QueuesInfoResponse>): void;
    }
    export class kubemqClient extends grpc_1.makeGenericClientConstructor(UnimplementedkubemqService.definition, "kubemq", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        SendEvent: GrpcUnaryServiceInterface<Event, Result> = (message: Event, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Result>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Result>, callback?: grpc_1.requestCallback<Result>): grpc_1.ClientUnaryCall => {
            return super.SendEvent(message, metadata, options, callback);
        };
        SendEventsStream: GrpcChunkServiceInterface<Event, Result> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<Event, Result> => {
            return super.SendEventsStream(metadata, options);
        };
        SubscribeToEvents: GrpcStreamServiceInterface<Subscribe, EventReceive> = (message: Subscribe, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<EventReceive> => {
            return super.SubscribeToEvents(message, metadata, options);
        };
        SubscribeToRequests: GrpcStreamServiceInterface<Subscribe, Request> = (message: Subscribe, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<Request> => {
            return super.SubscribeToRequests(message, metadata, options);
        };
        SendRequest: GrpcUnaryServiceInterface<Request, Response> = (message: Request, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Response>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Response>, callback?: grpc_1.requestCallback<Response>): grpc_1.ClientUnaryCall => {
            return super.SendRequest(message, metadata, options, callback);
        };
        SendResponse: GrpcUnaryServiceInterface<Response, Empty> = (message: Response, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Empty>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Empty>, callback?: grpc_1.requestCallback<Empty>): grpc_1.ClientUnaryCall => {
            return super.SendResponse(message, metadata, options, callback);
        };
        SendQueueMessage: GrpcUnaryServiceInterface<QueueMessage, SendQueueMessageResult> = (message: QueueMessage, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SendQueueMessageResult>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SendQueueMessageResult>, callback?: grpc_1.requestCallback<SendQueueMessageResult>): grpc_1.ClientUnaryCall => {
            return super.SendQueueMessage(message, metadata, options, callback);
        };
        SendQueueMessagesBatch: GrpcUnaryServiceInterface<QueueMessagesBatchRequest, QueueMessagesBatchResponse> = (message: QueueMessagesBatchRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<QueueMessagesBatchResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<QueueMessagesBatchResponse>, callback?: grpc_1.requestCallback<QueueMessagesBatchResponse>): grpc_1.ClientUnaryCall => {
            return super.SendQueueMessagesBatch(message, metadata, options, callback);
        };
        ReceiveQueueMessages: GrpcUnaryServiceInterface<ReceiveQueueMessagesRequest, ReceiveQueueMessagesResponse> = (message: ReceiveQueueMessagesRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ReceiveQueueMessagesResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ReceiveQueueMessagesResponse>, callback?: grpc_1.requestCallback<ReceiveQueueMessagesResponse>): grpc_1.ClientUnaryCall => {
            return super.ReceiveQueueMessages(message, metadata, options, callback);
        };
        StreamQueueMessage: GrpcChunkServiceInterface<StreamQueueMessagesRequest, StreamQueueMessagesResponse> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<StreamQueueMessagesRequest, StreamQueueMessagesResponse> => {
            return super.StreamQueueMessage(metadata, options);
        };
        AckAllQueueMessages: GrpcUnaryServiceInterface<AckAllQueueMessagesRequest, AckAllQueueMessagesResponse> = (message: AckAllQueueMessagesRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<AckAllQueueMessagesResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<AckAllQueueMessagesResponse>, callback?: grpc_1.requestCallback<AckAllQueueMessagesResponse>): grpc_1.ClientUnaryCall => {
            return super.AckAllQueueMessages(message, metadata, options, callback);
        };
        Ping: GrpcUnaryServiceInterface<Empty, PingResult> = (message: Empty, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PingResult>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PingResult>, callback?: grpc_1.requestCallback<PingResult>): grpc_1.ClientUnaryCall => {
            return super.Ping(message, metadata, options, callback);
        };
        QueuesDownstream: GrpcChunkServiceInterface<QueuesDownstreamRequest, QueuesDownstreamResponse> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<QueuesDownstreamRequest, QueuesDownstreamResponse> => {
            return super.QueuesDownstream(metadata, options);
        };
        QueuesUpstream: GrpcChunkServiceInterface<QueuesUpstreamRequest, QueuesUpstreamResponse> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<QueuesUpstreamRequest, QueuesUpstreamResponse> => {
            return super.QueuesUpstream(metadata, options);
        };
        QueuesInfo: GrpcUnaryServiceInterface<QueuesInfoRequest, QueuesInfoResponse> = (message: QueuesInfoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<QueuesInfoResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<QueuesInfoResponse>, callback?: grpc_1.requestCallback<QueuesInfoResponse>): grpc_1.ClientUnaryCall => {
            return super.QueuesInfo(message, metadata, options, callback);
        };
    }
}
